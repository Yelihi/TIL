## Context API 의 최적화

context API는 기존 React의 props 전달의 한계점을 해결해줄 수 있는, 별도의 라이브러리 설치 없이 가능한 아주 유용한 기능이다. 물론 recoil, redux 등 외부 상태관리 라이브러리들을 현업에서는 더 사용하게되지만, 좀 더 간단하지만 컴포넌트간의 상태 전달 상태가 꼬여있을 경우 그냥 Context API를 사용해주는 것이 좋다. <br />

사실 외부에서 상태를 관리하는것은 함수 컴포넌트 입장에서 조금 리스크를 앉고 가는 형태이다. 결국 함수이기에 전달받는 인자에 의한 확정된 반환값이 아닌 외부 요소에 의해 결정되는 것이기 때문이다. <br />

하지만 Context 를 통해 value 를 전달할 경우, 기존에 렌더링 최적화가 모두 초기화 현상이 발생할 수 있다. <br />

<img src="./images/context 최적화 필요이유.png" alt="최적화 이유" width="100%" />

<br />

위 구조를 살펴보게 되면, TodoContext.Provider 컴포넌트가 App 으로 부터 1개의 변화 상태값(todoLists)와 3개의 dispatch 를 전달받게 된다. 이후 Provider 자식 컴포넌트들에게 useContext 를 통해 각각 필요한 값을 전달받고 있다. <br />

여기서 만일 todoLists 가 dispatch 를 통해 업데이트 되었다고 가정해보겠다. 이렇게 되면 App 컴포넌트가 다시 렌더링이 진행되고, 당연하게도 props 로 전달하는 Provider 컴포넌트 역시 재랜더링이 발생하게 된다. <br />

여기까지는 쉽게 파악할 수 있는 내용인데, Provider 컴포넌트가 다시 렌더링이 되었다는것은 value 가 변경되었다는 것이고, 이는 useContext 로 값을 전달받는 컴포넌트들 모두 다시 렌더링 되어야 한다. 설사 memo 를 통해 전달받는 props 의 변화가 없다면 렌더링 되지 않는 경우도 이 경우는 무조건 다시 렌더링 된다. <br />

요약하자면, provider 컴포넌트가 다시 렌더링이 발생하면 이 provider 의 value 를 전달받는 자식 컴포넌트 모두 다시 렌더링된다. <br />

이와 같은 과정에서 최적화를 이루는 방법은, value 중에서 변화가 일어나는 상태값과, dispatch 같이 변화가 없는 값을 분리하여 따로 context 로 관리하는 방법이다. <br />

<img src="./images/context 분할 이후 최적화.png" alt="최적화" width="100%" />

<br />

변하는 상태와 그렇지 않은 상태를 구별하여 2개의 context 를 만들어서 따로 관리를 하고 있다. 이로서 만일 todoLists 가 업데이트 된다면 이와 관련된 TodoList 컴포넌트만 업데이트가 된다. 나머지 dispatch 의 경우는 변하지 않으니 그대로 있게 된다.<br />

물론 TodoList 가 변하였으니 자식 컴포넌트도 리렌더링 되어야 하지만, 여기는 memo로 관리하고 있기에 다시 렌더링되지 않는다.
