### 기본형과 참조형

<p>데이터에는 기본형과 참조형이 있으며, 원시값으로서 숫자, 문자, boolean, null, undefined, symbol 이 있습니다. 반면 참조형으로는 객체, 배열, 함수(객체)가 있습니다. 공부를 하다보면 자연스럽게 암기하게 되는 내용인데, 이러한 기준을 어떻게 나누는건지 간단하게 복습해봅시다.</p><br />

### 데이터 형식에 따른 구분

<p>0과 1로 이루어진 bit(비트) 가 8개 있는것이 1바이트입니다. 2바이트는 16비트이며, 4바이트는 32비트 입니다. 이러한 바이트는 데이터의 공간을 나타내는데, 예를 들자면 1바이트에서 구현할 수 있는 가짖수는 2^8 = 256 입니다. 수를 표현하더라도 이정도를 표현할 수 있는 것이죠. 자바스크립트의 경우 다른 언어와 달리 여유로운 데이터 공간을 제공합니다. 즉 8바이트이자 64비트의 데이터 공간을 부여받을 수 있죠. 하나의 변수를 선언할 때 변수의 크기는 8바이트입니다.</p><br />

<p>여기서 변수는 할당된 데이터 공간을 의미합니다. 그렇다면 우리가 부르는 변수이름은 무엇일까요. 바로 비트가 가지고 있는 유일한 식별자의 이름을 나타냅니다. 즉 변수명은 식별자라고 생각하면 됩니다. 여러 비트들이 모여있는 데이터 공간의 첫 비트의 식별자를 통해 우리는 데이터, 즉 변수에 접근할 수 있습니다. 이러한 변수 데이터 공간에는 이름과 값이 저장됩니다. 이렇게 생각하면 흔히 우리가 할당하는 데이터값이 값부분에 저장되겠구나 생각할 수 있습니다.</p><br />

<p>하지만 사실은 변수 데이터 공간의 값에는 실제 할당된 데이터의 주소가 저장이 됩니다. 즉 할당된 데이터는 다른 데이터공간에 할당되어 그 주소가 불려올 뿐입니다. 예를 들어서 아래 코드에서 변수를 선언하였다면</p>

```js
var a; // a 가 선언됨

a = 10; // 10이라는 데이터가 저장된 주소값이 변수 a 의 값에 할당된다
```

<p>위 처럼 변수 공간 a 에 직접 데이터를 할당하지 않습니다. 이러는 이유는 우선 변수는 말 그대로 변할 수 있음을 뜻하고, 숫자가 아닌 문자열이 저장될 수도 있는 것입니다. 앞에서 살펴보았지만 숫자의 경우 64비트라는 공간으로 제한되지만, 문자열은 딱히 그런것이 없습니다. 따라서 숫자에서 문자열으로 변경될 때 주어진 64비트 공간을 넘어서게 되면 늘리거나 해야하기에 불편합니다. 이러한 이유로 그냥 새롭게 값이 할당되면 할당되는 값은 새로운 데이터 공간에 할당이 되고, 이 주소값을 변수 a 가 가지게 됩니다.</p><br />

<p>뿐만 아니라 아래와 같은 상황을 살펴보겠습니다</p>

```js
var a = 10;
var b = 10;
var c = 10;
var d = 10;
var e = 10;

//.... 한 1000개의 다른 변수에 같은 값 10 을 할당한다
```

<p>이러한 경우 변수의 숫자 1000개에 해당하는 할당값 10도 1000개나 저장되어야 할 것입니다. 너무 비효율적이지 않나요? 이렇기 때문에 데이터를 따로 공간을 두어 저장한 다음 주소값을 불러오는 형식입니다. 엄밀하게 말하자면 기본형의 데이터 역시 참조형입니다. 그렇다면 불변값이라는 것은 어떠한 이유로 생긴 의미일까요?</p>

### 불변값

<p>변수와 상수(const) 를 구분하는 성질은 변경 가능성 입니다. 그러니깐 이 변수는 값이 변경될 수 있는지의 여부에 따라 변수와 상수를 나누게 됩니다. 즉, 한 변수의 할당된 값이 변화한다고 let 이 가변성이고 const 가 불변성이 아닌것입니다. 불변성을 따지는 영역은 데이터 영역입니다. 이 부분이 원시값과 객체와의 차이점이 드러나는 부분입니다.</p><br />

<p>원시값의 경우 앞서서 설명드렸듯이, 데이터값의 주소가 변수에 할당이 되며, 만일 새로운 값을 할당하면, 새로운 값은 새로운 데이터 공간에 저장되고 변수는 이 주소로 값을 변경하게 됩니다. 즉, 기존의 데이터값은 변하지 않고 그대로 인 상태입니다. 그래서 불변값입니다. 어떠한 방식으로도 기존 데이터영역의 데이터를 변경할 수 없습니다.</p>

```js
var a = 10;
a = 20; // 기존 10은 데이터영역에 그대로 존재한다.
```

<p>반면 참조형 데이터는 기본적으로 가변성을 띔니다. 그 이유는 데이터를 할당하는 방식에 있습니다. 객체는 보통 아래와 같은 프로퍼티와 값으로 이루어진 짝입니다.</p>

```js
var obj = {
  a: 10,
  b: "aaa",
};
```

<p>우선 변수명 obj 를 지니는 데이터 영역이 생성이 되고, 이때 obj(편의상 주소값을 1000번이라 하겠습니다.) 의 값은 임의의 데이터 공간에 저장하려다 보니, 데이터가 프로퍼티로 이루어진 그룹이라는 사실을 알게되고, 일단은 임의의 데이터 공간(5000)을 확보합니다. 그리고 확보된 데이터 공간은 프로퍼티 a, b 의 변수 데이터 공간(7001, 7002)을 참조합니다. 이 a, b 공간의 값은 각각 10 과 'aaa' 인데, 이 데이터 값을 데이터영역에서 찾아서 공간에 할당한 다음 그 주소값을 가져옵니다.(5003, 5004)</p><br />

<p>이렇게 되면 결국 obj 를 읽기 위해서는 1000 -> 5000 -> 7001,7002 -> 5003,5004 로 접근을 하게 됩니다. 이제 여기서 만일 내부 프로퍼티의 값을 변경했다고 가정하겠습니다. 즉 a 를 20으로 변경합니다. 20에 대한 새로운 데이터영역을 5005 라고 한다면, a 변수는 기존 5003 대신 5005 를 주소로 가지게 됩니다. 끝입니다. 그렇다면 obj 의 참조하는 값의 주소는 변경했나요? 아닙니다. 기존 그대로 5000번을 참조하고 있습니다. 이러한 특징은 변수를 복사하는 과정에서 기본형과 참조형의 차이점으로 드러나게 됩니다.(obj 변수에 원시값을 대입하면 주소 참조를 잃은 데이터 값들은 추후 가비지 셀렉터에 의해 지워집니다.)</p>

```js
var a = 10;
var b = a;

var obj1 = { c: 10, d: 20 };
var obj2 = obj1;
```

<p>위는 데이터를 복사하고 있습니다. 우선 원시값을 복사할 경우 역시나 같은 10이 저장된 데이터 주소를 참조할 것입니다. 즉, a와 b 는 모두 같은 주소를 참조합니다. 마찬가지로 obj1 과 obj2 역시 같은 객체의 주소를 참조하게 됩니다. 즉, 복사를 했을 때 흔한 지식으로 원시값은 참조하지 않는다고 알려졋지만, 사실은 모두 같은 주소를 참조하게 됩니다. 그렇다면 어디서 차이가 발생하는것일까요? 바로 복사에 있습니다.</p><br />

<p>우리가 데이터를 복사하는 이유는 원본 데이터를 보존하고 싶은 기대치가 있기 때문입니다. 위 예시를 그대로 따라가면서 이제 복사된 값에 새로운 값을 할당해주겠습니다.</p>

```js
b = 100;

console.log(a); // 10;

obj2.c = 20;

console.log(obj1.c); // 20 ?
```

<p>기본형의 경우 b 에 새로운 값 100을 할당해주었습니다. 100은 임의의 데이터 공간을 차지할 테고, 이 주소를 변수 b 가 값으로서 참조하게 됩니다. 즉 a 와 b 는 서로 다른 주소를 참조하고 있습니다. 이렇기 때문에 아무리 b 를 변경해도 a 는 그대로입니다.(데이터값은 불변이기 때문입니다)</p><br />

<p>반면 객체의 경우 얘기가 달라집니다. obj1과 obj2 는 모두 5000이라는 주소값을 참조한다고 가정하겠습니다. 이때 5000 은 원시값이 아닌 그룹 데이터의 주소값을 참조하고 있습니다. 바로 c 와 d 입니다. 위에서는 c 의 할당된 데이터값을 20으로 변경했습니다. 이 말은 c 가 참조하는 주소값이 변경되었다는 의미입니다. 즉 c 는 성공적으로 변경되었습니다. 하지만 중요한점은 obj1 과 obj2 가 참조하는 5000 은 그대로입니다! 그렇기 때문에 위 콘솔에서 obj1.c 역시 변경된 값을 출력하게 되는 것입니다. 분명 복사된 값을 변경하였는데 기존 객체의 값이 변경이 되었습니다. 이러한 점에서 참조형은 가변값이라고 설명할 수 있습니다. </p><br />

<p>헌데 이 부분도 약간 보충 설명이 필요합니다. 아래 예제를 봅시다</p>

```js
var obj1 = { c: 10, d: 20 };
var obj2 = { c: 10, d: 20 };

obj2.c = 20;
console.log(obj1.c); // 10
```

<p>위 처럼 변수로서 복사하는것이 아닌, 새로운 객체값을 할당하는 경우 복사가 이루어집니다. (물론 프로퍼티의 값이 원시값이라는 조건하에). 왜냐하면 새로운 객체는 새로운 데이터 공간을 차지하기 때문입니다. 이렇게 보면 객체를 복사할 경우, 가변성이라고 하는 경우는 내부의 프로퍼티를 변경할 경우에 한해서 성립한다고 생각해도 됩니다. </p>

### 얕은 복사

<p>프론트단에서 객체의 불변성을 중요하게 여긴것은 오래되었습니다. 최근의 라이브러리나 프레임워크, 디자인 패턴 등 여러 상황에서 객체의 불변성은 필요합니다. 앞서서 객체가 불변성을 가지는 경우는 또 하나의 같은 값을 가지는 객체를 대입해주었을 때 입니다. 이 방식을 대표적으로 활용하는 방법이 얕은 복사입니다.</p>

```js
let user = {
  name: "wonik",
  gender: "male",
};

export const changeObj = (user, newName) => {
  let newUser = {};
  for (let prop in user) {
    newUser[prop] = user[prop];
  }
  newUser.name = newName;
  return newUser;
};

let user2 = changeObj(user, "Jung");

if (user !== user2) {
  console.log("유저정보가 변경되었습니다.");
}
```

<p>객체 user 가 있고 이를 복사하고 싶습니다. 잘 복사되었다면 콘솔로그가 발동될 것입니다. 함수 changeObj 는 새로운 객체 newUser 를 생성한 뒤, 기존 user 의 각각의 프로퍼티를 전부 복사합니다. 이후 newUser 를 return 합니다. 실제 가동해보면 정상적으로 콘솔이 작동하게 됩니다.</p><br />

<p>최근에는 그저 스프레드 연산자를 활용해서 {...user} 로서 얕은 복사를 하는 편입니다. 직관적인 표현이기 때문입니다. 얕은 복사는 대부분의 문제를 잘 해결해주지만, 만일 프로퍼티가 원시값이 아닌 또 다른 객체를 할당하고 있다면 얘기가 달라집니다. 얕은 복사를 해도, 결국 내부 객체값은 기존 객체값의 주소를 같이 참조하고 있기 때문입니다. 이러한 상황에서 필요한 것은 깊은 복사입니다. 내부 객체까지도 모두 새로운 데이터 영역으로 복사하는 과정인것입니다. 아래 예시를 살펴보겠습니다.</p>

```js
let user3 = {
  name: "Wonik",
  age: 20,
  urls: {
    portfolio: "https://closet-online.com",
    blog: "https://rock7246.tstory.com",
    facebook: "none",
  },
};

let user4 = changeObj(user3, "Jung");
user4.urls.blog = "";

console.log(user3.urls.blog); // ""
```

<p>우선 깊은 복사가 이루어지지 않았을 경우 위처럼 복사된 객체를 수정하였지만 원본도 수정이 되어버립니다. 이러면 기존 changeObj 함수를 변경할 필요가 있겠습니다.</p>

```js
const changeObj = (target) => {
  const result = {};
  if (typeof target === "object" && target !== null) {
    for (let prop in target) {
      result[prop] = changeObj(target[prop]);
    }
  } else {
    // prop 이 원시값이라면
    result = target;
  }

  return result;
};
```

<p>재귀함수를 통해 위처럼 표현했습니다. 재귀함수의 효율은 좋지 않으나 일단은 위 방법처럼 진행하면 깊은 복사가 됩니다. 바뀐 함수로 다시 위의 복사과정을 진행하면 성공적으로 복사가 이루어졌음을 알 수 있습니다. 다른 깊은 복사의 방식이 있다면 아래와 같습니다.</p>

```js
const changeObj = (target) => {
  const result = JSON.parse(JSON.stringify(target));
  return result;
};
```

<p>json 으로 변환 후 다시 파싱하는 과정으로 객체를 깊은복사할 수 있습니다. 다만 위와 같은 복사로는 메서드나 getter, setter, __proto__ 와 같이 json 으로 변환이 되지 않는 부분은 모두 무시해버립니다. 그래서 위와 같은 방식은 서버로부터 받은 데이터를 복사할 때 사용하곤 합니다.</p>

### getter, setter 를 복사하려변 무슨 방법을 써야 할까

<p>깊은 복사를 하더라도 getter, setter 의 경우 조금 다른 방법으로 접근해야합니다. 아직까지는 getOwnPropertyDescriptor 를 사용하지 않고는 복사를 할 수 없습니다. 기본적으로 getter 와 setter 는 은닉화, 즉 캡슐화를 위해 사용되곤 합니다. 프로퍼티는 데이터 프로퍼티가 있고 접근자 프로퍼티가 존재하는데, 지금까지 다루었던 프로퍼티는 모두 데이터 프로퍼티입니다. 반면 getter 와 setter 의 경우 접근자 프로퍼티로서 데이터를 반환하거나 수정할 때 호출할 수 있습니다. 그냥 프로퍼티를 호출하고 수정하면 되지 뭐하러 getter 와 setter 를 사용하는가에 대한 대답은, 마치 함수처럼 기존 데이터 프로퍼티를 가공하여 반환할 수 있고, 조건을 받아서 수정할 수 있다는 장점이 있기 때문입니다. class 에서 getter 와 setter 가 활용될때는 내부 변수를 은닉화를 할 때 활용합니다. (사실 이게 주된 목적입니다.)</p><br />

<p>이러한 getter 와 setter 를 사용할 때 주의할 점은 객체 내부 프로퍼티와 같은 이름을 사용해서는 안된다는 점이 있습니다. 같은 이름을 사용해버리면 무한루프에 빠져버리는데 아래 코드를 살펴봅시다.</p>

```js
const infinite = {
  name: 'wonik',

  get name(){
    return this.name;
  }

  set name(value){
    // this.name 자체가 set name 의 호출입니다.
    // 의도대로라면 내부 프로퍼티 name 을 변경하려 한 것이지만,
    // 결국 infinite.name 의 호출이 되면서 계속해서 setter 를 호출하게 됩니다.
    this.name = value;
  }
}

infinite.name = 'choi' // 무한호출

```

<p>이렇게 무한 호출되는 경우를 조심하고, 데이터를 수정하고 싶을 때는 getter 와 setter 모두 설정해주어야 합니다. 여튼 이러한 getter 와 setter 를 복사하기 위해서는 기존 방식으로 처리해서는 안됩니다. 예를 들어보자면</p>

```js
let user3 = {
  name: "Wonik",
  age: 20,
  urls: {
    portfolio: "https://closet-online.com",
    blog: "https://rock7246.tstory.com",
    facebook: "none",
  },

  get _age() {
    return this.age;
  },

  set _age(value) {
    this.age = value;
  },
};

let user4 = changeObj(user3, "choi won ik");

console.log(user3._age); // 20
user3._age = 33;
console.log(user3._age); // 33
console.log(user3.age); // 33
user4._age = 40;
console.log(user4._age); // 40
console.log(user4.age); // 20
```

<p>원본 객체의 setter 는 제대로 작동을 합니다. 하지만 복사된 setter 는 제대로 작동하지 않습니다. 어떠한 이유로 작동을 안하는지는 아직 자세히 파악하지 못하였으나, 이를 해결하는 방법은 다음과 같습니다.</p>

```js
// user3 의 getter, setter 인 _age 를 가져옵니다.
var BazValue = Object.getOwnPropertyDescriptor(user3, "_age");

// user4 의 프로퍼티이자 getter와 setter 가 될 부분인 _age 에 BazValue 를 기입합니다.
Object.defineProperty(user4, "_age", BazValue);
```

<p>이렇게 했을 경우 제대로 작동함을 확인할 수 있습니다.</p>

### undefined, null

<p>간략하게 두가지의 차이점을 살펴보자면, 결국 개발자의 의도가 들어가있느냐와 아니냐로 판단하고, 또 코드를 작성할때도 그렇게 하는게 좋습니다. 기본적으로 자바스크립트 엔진은 undefined 를 응당 어떤값을 저장할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined 를 반환합니다.</p><br />

- 값을 대입하지 않은 변수
- 객체 내부의 존재하지 않는 프로퍼티에 접근할 때
- return 문이 없거나 호출되지 않은 함수의 실행 결과

<p>반면 null 은 사용자가 명시적으로 없음을 표현하기 위해 대입한 값입니다. 따라서 본래의 의미에 따라 없음을 표현하고 싶을때는 null을 활용하는것이 좋습니다.</p>
