## Programers - 롤케이크자르기

### 문제 설명

철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다. 그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다. <br /><br />

예를 들어, 롤케이크에 4가지 종류의 토핑이 올려져 있다고 합시다. 토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때, 케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다. 만약 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면 롤케이크의 토핑은 [1, 2, 1], [3, 1, 4, 1, 2]로 나뉘게 됩니다. 철수가 [1, 2, 1]이 놓인 조각을, 동생이 [3, 1, 4, 1, 2]가 놓인 조각을 먹게 되면 철수는 두 가지 토핑(1, 2)을 맛볼 수 있지만, 동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것이 아닙니다. 만약 롤케이크의 네 번째 토핑(3)과 다섯 번째 토핑(1) 사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘게 됩니다. 이 경우 철수는 세 가지 토핑(1, 2, 3)을, 동생도 세 가지 토핑(1, 2, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것입니다. 공평하게 롤케이크를 자르는 방법은 여러가지 일 수 있습니다. 위의 롤케이크를 [1, 2, 1, 3, 1], [4, 1, 2]으로 잘라도 공평하게 나뉩니다. 어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다.
<br /><br />

롤케이크에 올려진 토핑들의 번호를 저장한 정수 배열 topping이 매개변수로 주어질 때, 롤케이크를 공평하게 자르는 방법의 수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- 1 ≤ topping의 길이 ≤ 1,000,000
- 1 ≤ topping의 원소 ≤ 10,000

### 문제 풀이

제한 사항을 보자마자 이건 단순 순회로도 시간 초과가 발생할 수 있겠다 라고 생각했다. 다만 우선 그렇게 초과가 나는지 먼저 가장 간단한 로직으로 문제를 풀어보려고 했었다. <br />

문제를 이해하는데는 어려운건 없었다. 말 그대로 배열을 쪼개서, 토핑의 갯수(중복허용하지않음)가 같아진다면 올바르게 자른것이고 횟수를 늘려주면 된다. 가장 간단하게 생각할 수 있는 방법은, Set 의 활용과 slice 를 통한 배열 쪼개기이다. 순회를 돌면서 배열을 쪼갠 다음에 각 배열을 Set 으로 담아 size 를 비교하면 된다. 그리고 실제로 이렇게 코드를 작성하니 바로 시간초과가 발생했다. 왜 시간 초과일까?
<br />

잘 몰랐던 부분인데 slice 의 시간복잡도는 n 이다. 따라서 중첩 순회가 되어버리게 되었고 당연하게도 시간초과가 발생하게 되었다. 그렇다면 어떤식으로 처리를 해야할까? 여기서부터가 고민의 시작이었는데, 계속 생각해보니 굳이 배열을 따로 생성할 필요가 없음을 깨달았다.

- 한번의 순회에서 2가지 Set 을 컨트롤 할 수 있음을 알게 되었다
- 예를 들어 첫번째 토핑을 동생이 가지도록 set1.add(topping[i]) 라고 할 때, 동시에 형이 가질 토핑의 갯수도 구할 수 있었다. (set2.add(topping[len-2-i]))
- 이런식으로 순회를 한번 돌고나면, 각 자르는 위치에 따른 형과 동생의 케이크 토핑의 갯수가 각각 set1, set2 에 담겨있게 된다.
- 또한 순회를 돌 때 마다 2개의 dp 배열에 set.size 를 저장함으로서 불필요한 순회를 막을 수 있다.

말로만 하니 뭔가 햇갈리니 코드를 살펴보자 <br />

```js
function solution(topping) {
  let count = 0;
  const len = topping.length;

  const dpLeft = [];
  const dpRight = [];

  const setLeft = new Set();
  const setRight = new Set();

  for (let i = 0; i < len; i++) {
    setLeft.add(topping[i]);
    setRight.add(topping[len - 2 - i]);
    dpLeft[i] = setLeft.size; // 매 순회마다 size를 재어서 토핑의 갯수를 dp 에 기입한다. (컷팅 위치에 따른 토핑의 갯수)
    dpRight[len - 2 - i] = setRight.size;
  }

  // 순회를 마친 다음 한번 더 순회를 돌면서 비교해주자
  dpLeft.forEach((topping, idx) => {
    if (topping === dpRight[idx]) count++;
  });

  return count;
}
```

### 다른 풀이

```js
function solution(topping) {
  const [b1Dict, b1Arr, b2Dict, b2Arr] = [new Set(), [], new Set(), []];
  topping.forEach((t1, i) => {
    const t2 = topping.at(-i);
    b1Dict.add(t1);
    if (i !== 0) b2Dict.add(t2);
    b1Arr.push(b1Dict.size);
    b2Arr.push(b2Dict.size);
  });
  return b1Arr.reduce(
    (acc, cur, i) => (cur === b2Arr.at(-i - 1) ? acc + 1 : acc),
    0
  );
}
```
