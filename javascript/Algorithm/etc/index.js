// 소수 구하기 O(sqrt(n));

function is_prime(num) {
  for (let i = 2; i * i <= num; i += 1) {
    if (num % i == 0) {
      return false;
    }
  }

  return true;
}

// 에라토스테네스의 체
// 2부터 54 중 소수를 구하기

// 가장 먼저 2를 선택한다. 그리고 2의 배수를 선택한다.
// 그 다음 3을 선택하고, 3의 배수수를 선택한다.
// 5를 선택하고 5의 배수를 선택한다.

function get_primes(num) {
  const prime = [false, false, ...Array(num - 1).fill(true)];

  for (let i = 2; i * i <= num; i += 1) {
    if (prime[i]) {
      for (let j = i * 2; j <= num; j += 1) {
        prime[j] = false;
      }
    }
  }

  return prime.filter(boolean);
}

// 다익스트라
// 최단경로 구하기 알고리즘
// 간선 가중치가 다를때 사용

/**
 * 우선순위 큐로 만들 수 있다
 * 시간복잡도는 V가 정점의 수, E가 간선의 수일때 O(ElogV)
 * 시작점을 제외한 모든 정점의 거리를 무한으로 설정한다. 시작점은 0으로 설정한다
 * 시작점을 선택한다
 * 선택한 저점에서 갈 수 잇는 정점의 거리를 정점(해당 정점까지의 최단거리) + 간선 으로 갱신한다
 * 선택한 정점을 방문 처리한다
 * 이미 방문한 정점과 무한인 정점을 제외하고 가장 최단 거리인 정점을 선택한다
 * 더이상 방문할 수 있는 정점이 없을 때 까지 3~5를 반복한다
 * 도착점의 값을 확인한다
 */

/**
 * 최소신장
 * 신장 트리란 그래프 내에 모든 정점을 포함하는 최소 연결 부분 그래프
 * 최소 신장 트리(MST)는 다음과 같은 조건을 만족해야 한다
 * - 최소한의 간선으로 모든 정점이 연결되어야 한다
 * 모든 신장 트리 중 가중치의 값이 최소여야 한다
 * Cycle 이 발생해서는 안된다
 *
 * 크루스칼 알고리즘
 * 그리디 개념을 이용하여 구현할 수 있다
 * 먼저 모든 그래프를 부분 집합으로 분리한다
 * 가장 가중치가 낮은 간선을 선택하고 부분집합을 연겨랗ㄴ다
 * 이때 Cycle 이 발생하지 않도록 주의한다
 * - 공통 최상위 부모를 찾는 것으로 막을 수 있다
 * - cycle을 판단하기 위한 알고리즘으로 Union-find 알고리즘을 통해 알 수 있다
 *
 * Union-find 알고리즘
 * 서로소 집합을 구하기 위한 알고리즘
 * - 서로소 집합은 공통 원소가 없는 두 집합을 표현하기 위한 자료구조
 * 서로 다른 두 집합을 병합하는 연산 Union과 집합의 원소가 어떤 집합에 속해 있는지 판단하는 연산 find 를 나타낸다.
 * 보통 트리 구조로 구성한다
 * 편의상 재귀로 구현하는 경우가 많다.
 *
 * 가장 가중치가 낮은 간선부터 선택 = 그리디
 * 각 원소가 같은 집합인지 확인하기 위한 알고리즘 = Union-find
 * 두 정점이 같은 집합에 속한다면 = Cycle
 */

/**
 * 백트래킹
 * 모든 경우의 수를 탐색하는 알고리즘
 * DFS 나 BFS 를 이용할 수 있다
 * 효율을 위해 탐색하지 않아도 되는 곳을 미리 막는 것을 가지치기 라고 한다
 * 자바스크립트는 재귀 효율이 나쁘기 때문에 DFS 를 구현할 경우 스택을 이용하는 것이 좋다
 * 다만 코테는 재귀써도 풀 수 있도록 문제를 출제하기도 한다
 * 순환이 발생한다면 bfs 가 더 좋다.
 */

/**
 * 우선 모든 경우의 수를 찾을 수 있도록 코딩
 * 문제에서 특정한 조건을 만족하는 것만 탐색하고 나머지는 탐색하지 않도록 조건문을 작성한다
 * 절대로 답이 될 수 없는 것은 탐색하지 않는다
 */

/**
 * n-queen
 * 1,1 에 퀸을 배치
 * 첫줄은 다른 퀸을 둘 수 없다
 * 두번째 줄 첫번째 열은 둘 수 없다. 또한 대각선도 둘 수 없다
 * 이런식으로 1,2 로 진행을 이어간다
 */

/**
 * 동적 계획법
 * DP 라고 부르기도 한다.
 * 메모리를 많이 사용하는 대신 빠른 성능을 자랑한다
 * 두가지 방법론이 있는데, 메모이제이션과 타뷸레이션 이 있다.
 */

/**
 * 메모이제이션은 하향식 접근법이며 작은 문제를 저장해놓아다 꺼내 쓴다고 생각하자
 * 예시는 피보나치 수열을 들 수 있다.
 * 피보나치의 가장 작은 문제는 1과 2다. 첫번째와 두번째가 각각 1이라는 걸 알고있다
 * 규칙은 f(n) = f(n -1) + f(n-2)
 */

/**
 * 타뷸레이션은 상향식 접근법이다.
 * 미리 계산해놓는다는 개념. 코테에서는 잘 쓰이진 않는다
 */

/**
 * 가장 작은 문제를 정의할 수 있는지
 * 작은 문제를 통해 큰 문제를 해결할 수 있는 규칙이 있는지
 * 이 2가지 관점이 DP 를 파악하는 개념이다
 */
