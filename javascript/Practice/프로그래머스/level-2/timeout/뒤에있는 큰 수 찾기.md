## Programers - 뒤에 있는 큰 수 찾기

### 문제 설명

정수로 이루어진 배열 numbers가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다.<br /><br />
정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다.<br /><br />

### 제한사항

- 4 ≤ numbers의 길이 ≤ 1,000,000
- 1 ≤ numbers[i] ≤ 1,000,000

### 문제 풀이

못 풀었던 문제다. 아이디어는 거진 동일했으나 시간초과에서 헤어나오질 못했다. 사실 다른 풀이를 봐도 이해가 잘 되지 않았다. <br /><br />

일단 numbers 길이만큼 -1 로 채워진 배열을 만든다. 이후 stack 을 활용할 것인데, numbers 를 한번의 순회를 돌면서, stack 에 번호를 계속 쌓다가 어느 순간 이전 번호보다 더 큰 번호가 나온다면 멈추고 -1이 채워진 배열의 index 를 찾아가 number 를 넣어준다.<br /><br />

이때 조건으로 기존에 만든 -1 배열에서 -1이 아니라면 이미 한번 뒷큰수로 적용시킨것이기에 무시해야한다. 이를 주의하자. <br /><br />

이러한 조건으로 문제를 풀이하면 <br /><br />

```js
function solution(numbers) {
  // 우선 numbers 길이만큼 -1이 포함된 배열을 만들어주자.
  const answerArray = Array(numbers.length).fill(-1);
  // 다음 순회를 돌면서 활용할 stack 을 준비한다.
  const stack = [];

  // numbers 를 1번 순회해줄 예정이다.
  numbers.forEach((number) => {
    // stack 의 마지막 index
    const lastIndex = stack.length - 1;

    // 만약 뒤 숫자가 그 전 숫자보다 크다면
    if (number > stack[lastIndex]) {
      // 이 숫자부터 쭈욱 확인해주어야 한다.
      // 우선 무한루프를 벗어날 인덱스 변수가 필요하다
      let backTrack = 0;

      while (number > stack[lastIndex - backTrack]) {
        // answerArray 의 원소가 -1인지 확인하자.
        if (answerArray[lastIndex - backTrack] == -1) {
          // -1 이면 아직 뒷수가 정해진것이 아니니 대입해주어도 된다.
          answerArray[lastIndex - backTrack] = number;
        }
        // backTrack 을 증가시킨다
        backTrack++;
      }
    }
    // while 을 통해서 순회를 다 돈다. (큰 숫자가 되는 지점부터)
    // 만일 while 조건이 해당하지 않거나, 한번 순회를 다 돈 것이라면 이제 stack 에 number 를 추가해준다.
    stack.push(number);
  });

  return answerArray;
}
```

<br />

문제를 풀면서 계속 힘들게 했던것은 배열내 index 를 각 번호가 기억하고 있어야 한다는 점에 있었다. 이미 뒷수가 정해진 것은 stack 을 통해 더 이상 변하면 안되는 것이다.
예를 들어 2,3,3,5 에서 첫번째 2의 뒷수는 3이다. 추후에 5가 나왔다 한들 첫번째 뒷수인 3을 5로 변경해서는 안된다. <br />
처음에는 이 부분을 부분배열로서 두번째 인자를 true, false 로 처리하려고 했다. 이 아이디어는 나쁜것 같진 않다. 위 식에서 조금 수정해도 충분히 적용할 만한 아이디어라 생각이 든다. 다만 이렇게 하면 요구사항대로 또 배열을 수정해주어야 하고 여기서도 추가적인 순회작업이 들어가게 된다. 이 부분이 계속 문제로 남아있었다. <br /><br />

두 번째로 부분적이지만 while 을 통해서 결국 첫번째 원소까지 뒤에서부터 순회를 해야한다는 점이었다. 지금 생각해보면 내가 잘못 판단하고 있었던 것이었고, while 조건 역시 잘못 주고 있었다. 왜 난 이때 이렇게 생각하지 못했을까 생각하는데, 가장 먼저 든 이유는 stack 을 구현할 때 무의식적으로 pop 을 이용하려고 했다는 점이다. 사실 이 문제에서는 pop을 이용할 필요가 없다. 오히려 index 를 찾아가 숫자를 변경해주면 되는것이다. (마치 dfs의 visited 마냥) 이번 기회에 stack 을 활용함에 있어서 자동적으로 pop 을 떠오르지는 말자. 이렇게 순서가 중요한 문제는 배열 내 원소를 직접 찾아가 변경해주는게 용이할 수 있다.<br /><br />

마지막으로 큰수가 존재하지 않을 때 -1 을 해주는 부분에 있어서 마지막에 따로 false 인 부분을 다 -1 로 변경해주는 로직을 작성했었다. 하지만 처음부터 -1 로 만들어놓고 뒷수가 있는것을 채워넣는다는 방식으로 접근했다면 좀 더 빨리 문제를 풀 수 있었지 않을까 생각한다. 예외 조건을 시작으로 옳은 조건을 채워나가는 사고 방식을 연습하자.
