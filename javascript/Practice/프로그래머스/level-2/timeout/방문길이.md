## Programers - 방문 길이

### 문제 설명

게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다. <br /><br />

- U: 위쪽으로 한 칸 가기

- D: 아래쪽으로 한 칸 가기

- R: 오른쪽으로 한 칸 가기

- L: 왼쪽으로 한 칸 가기
  <br /><br />

캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.<br />
이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)<br /><br />

단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.<br /><br />

명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요.

### 제한사항

- dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L' 이외에 문자는 주어지지 않습니다.
- dirs의 길이는 500 이하의 자연수입니다.

### 문제 풀이

2시간을 넘겼지만 결국 풀지 못했다. 접근은 근접했는데, Set 자료구조와 자바스크립트의 특성을 제대로 활용하지 못한것이 화근이었다. 그리고 무지성으로 좌표계가 보이니 바로
2차원 행렬을 만들어 해결하려고 했던 점이 패인이다. <br /><br />

이 문제를 그래프를 통해 2차원 행렬의 데이터 변화로 풀기에는 문제가 있다. 좌표만으로는 문제의 요구사항을 채울 수가 없다는 점이다. 예를 들어서 이미 방문했었던 좌표점을 visited 처리 해서 만일 이동하려는 좌표가 visited 되어있다면 지나간 곳이기에 거리를 증가시키지 않는 로직을 짜게 되면 얼추 그럴싸 하지만 문제가 발생한다.<br />
설사 visited 처리가 되어있는 좌표라 할 지언정 어느 위치에서 접근하는가? 혹은 어느 좌표로 이동하는가에 따라서 거리를 1 증가시켜야 한다는 점에 있다. <br /><br />

뒤늦게 이를 파악하여, 추가적인 정보가 더 있어야 한다는 것을 깨달았다. 즉, (0, 1) 에서 (0, 2) 로 이동을 하였다고 했을 때, 단순히 (0, 2) 의 visited 를 true 로 만들어 주는것으로 되는게 아니라, (0, 1) -> (0, 2) / (0, 2) -> (0, 1) 이라는 흐름을 저장했어야 했다. 이렇게 해야지만 지나갔던 길에 대해서 중복없이 처리가 가능해진다. 이제 문제는 이러한 정보를 어떻게 추가할 것인가였다. <br /><br />

중복 처리에 있어서 떠오르는 자료구조는 Set 이다. Set.add 를 통하면 중복처리를 해주지 않아도 알아서 중복을 걸러준다. 헌데 내가 작성한 코드에서는 그렇게 되지 않았다. 좌표 정보를 기입하기 위해 [row, [col, col-1]], [row, [col-1, col]] 이런식으로 이중배열로 값을 저장했는데, 저장할때마다 중복처리를 하지 않았다. 즉,
[1, [1, 2]] 가 2번 들어와 있었다는 의미. 내 생각에는 배열은 객체이고 객체는 원시값이 아니기 때문에 구별을 못하는것 같았다. 여기서 더 생각했다면 문자열로 변경하여 저장하는 방안이었는데, 이를 미처 생각하지 못한게 크다... <br /><br />

```js
function solution(dirs) {
  const set = new Set();
  let row = 5;
  let col = 5;
  [...dirs].forEach((order) => {
    switch (order) {
      case "U":
        if (row - 1 < 0) break;
        else {
          set.add(`${row}${col}${row - 1}${col}`);
          set.add(`${row - 1}${col}${row}${col}`);
          row -= 1;
          break;
        }
      case "D":
        if (row + 1 > 10) break;
        else {
          set.add(`${row}${col}${row + 1}${col}`);
          set.add(`${row + 1}${col}${row}${col}`);
          row += 1;
          break;
        }
      case "L":
        if (col - 1 < 0) break;
        else {
          set.add(`${row}${col}${row}${col - 1}`);
          set.add(`${row}${col - 1}${row}${col}`);
          col -= 1;
          break;
        }
      case "R":
        if (col + 1 > 10) break;
        else {
          set.add(`${row}${col}${row}${col + 1}`);
          set.add(`${row}${col + 1}${row}${col}`);
          col += 1;
          break;
        }
    }
  });

  return set.size / 2;
}
```

<br />

위 코드처럼 문자열로 변경하여 저장해주면 Set 은 알아서 중복처리를 해준다. 거리는 Set.size / 2 를 해주면 구해진다.
