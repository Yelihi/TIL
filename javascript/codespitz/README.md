## 77

### memory, address, pointer, variables, dispatch

메모리는 고유한 번호를 가지는 블록체계로 이루어져 있다. 4bit, 64bit 등등에 따라 메모리 크기가 결정이 된다.
<br />
데이터가 저장되면 각 메모리에 맞게 데이터가 저장이 되고, 그 주소가 부요된다. 예를 들자면

```
A = 'TEST' &A = 11
```

근데 B라는 곳에는 A의 주소만 저장하고 싶다고 하자

```
B = &A *B = 'TEST'
```

위 표현 방식은 C의 방식이다. 주소를 저장한 B에서 그 주소에 대한 값을 얻기 위해서는 (\*) 을 붙여주면 된다.
<br />

근데 이러한 변수는 계속해서 퍼져나간다. 즉 개발을 할 떄 주의할 점은 내가 만든 변수를 누군가가 어떻게 접근할지 모른다는 점이다. 우리의 통제권을 넘어서게 된다. 만약 C,D 역시 B 를 참조한다고 해보자. B는 A의 주소값을 가지고 있고, 따라서 C,D 역시 A의 주소값이 복사되어있다.
<br />

이제 최악의 상황을 생각해보자. B는 A 를 가르켜야 하는데, 이 아이가 &K 를 가리키기 시작했다. 예정대로 C,D 는 A를 가리키고 있고, B는 K 를 가리킨다. 근데 웃긴건 분명 C = B, D = B 에서 모순점이 생겨버린다. 개발자는 C와 D가 같다고 알고 있는데, 실제 메모리 구조는 전혀 다른 결과를 보여주고 있는 것이다.
<br />

이걸 해결하기 위한 방법으로는 참조의 참조를 이용하는 방법이 있다.

```
B = { value: &A, V: 3 }
C = B
D = B

```

위처럼 B에 바로 A의 주소를 복사하는 것이 아니라, 새로운 객체를 생성하고, 그 key 들에 대한 값들을 다른 메모리 공간에 저장하는 것이다. 예를 들어 value 의 값은 12번주소, V의 값은 20번 주소라고 해보자. 또한 B 자체는 2번 주소라고 하겠다.
<br />

이렇다면 C와 D는 2번 주소를 복사하게 된다. A에 접근하고 싶다면 B.value 로 접근할 수 있겠다. 이제 만약 B의 value 가 K로 변경이 되었다고 해보자. K의 주소는 33번이고, 이렇게 된다 한들 C와 D는 여전히 같은 2번 주소를 가리키고 있다. 만약 새롭게 B가 참조하는 주소를 얻고싶다면, C.value, D.value 이런식으로 처리하면 될 것이다.
