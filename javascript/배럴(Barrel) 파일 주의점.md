## (번역) Barrel 파일의 주의점

프로젝트 내 import, export 의 패턴을 보면 좀 더 간략하게 하기 위해 매 폴더마다 index.js 를 통해 한꺼번에 import 해 온 다음 다시 export 하는 방식을 자주 사용하곤 한다. 하나의 파일에 여러 import 문이 생기는 것 보다 path 부분에서나, 코드 부분에서나 더 간단하기 때문이다. <br />

```js
import { foo } from "./some/other-file";

export function myCoolCode() {
  // foo 는 매우 똑똑한 코드로 얼마 시간이 걸리지 않는다.
  const result = foo();
  return result;
}
```

<br />

하나의 가정을 해보자. foo 라는 함수는 아주 효율이 좋은 함수로서 실행이 되자마자 바로 결과를 반환할 만큼 효율이 좋다. 그런데 실제 myCoolCode 를 실행시켰을 때 이상하게 반환이 느리다고 하자. 원인을 알기 위해 foo 위 아래 console.time 을 통해 시간을 측정해본다. <br />

```js
import { foo } from "./some/other-file";

export function myCoolCode() {
  console.time();
  const result = foo();
  console.timeEnd(); // 매우 짧은 시간으로 측정이 된다.
  return result;
}
```

<br />

측정 결과 foo 함수에는 문제가 없어 보인다. 그렇다면 왜 이 myCoolCode 함수는 실행이 늦게 되는 것일까? 일단 알 수 있는 점은 느린 속도가 런타임의 문제가 아니라는 점이다. <br />

일부 npm 패키지는 성능상의 이유로 코드를 미리 번들링 한다는 이야기가 있다. 번들러가 하는 일은 모듈 그래프를 평평하게 만들고 병합하는 것이고 이는 수천개의 파일로 구성되던 모듈 그래프를 단일 파일로 병합한다는 의미이다. 실제 위 코드를 esbuild 를 통해 번들링 한 후 실행하면 속도가 기하급수적으로 빨라질 수 있다. <br />

즉, 문제는 외부에서 foo 를 import 해오는 데 걸리는 시간이라는 점을 알 수 있다 <br />

### 베럴 파일 해부

베럴 파일은 다른 파일만 내보내고 코드 자체는 포함하지 않는 파일이다. 예를 들자면 이런것이다. <br />

```js
// 여러 경로에서 각각 import 해오고 있다.
import { foo } from "../foo";
import { bar } from "../bar";
import { baz } from "../baz";
```

<br />

예전에는 에디터에 자동 Import 가 없어서 개발자가 전부 직접 import 해야했기에 불편함이 있었고, 이를 해결하고자 하나의 index.js 파일에 import 해오고 이를 다시 export 하는 패턴이 생겨났다.

```js
// feature/index.js
export * from "./foo";
export * from "./bar";
export * from "./baz";

// 외부 import 시
import { foo, bar, baz } from "../feature";
```

<br />

파일 갯수가 그리 많지 않다면 분명 깔끔한 방식이지만, 반드시 좋은 방법이라고만은 할 수 없다.

### 문제가 되는 방향

보통 설계를 하다보면 import, export 의 관계가 체인처럼 연결되어있을 가능성이 높다. 즉 어떤 파일을 import 하는 베일을 import 하고, 이 배럴 파일을 또 다른 배럴 파일이 가져오는 식으로 말이다. 이러다보면 의도치 않게 한 함수를 사용하기 전 이 함수와 연결된 모든 배럴 파일을 실행해야 할 수도 있는것이다. 점점 프로젝트의 규모가 커질 수록 이런 모듈을 로드하는데 시간이 오래걸리게 될 것이다. <br />

모듈은 필요할 때만 알아서 선택되어 로드되지 않는다. 이를 주의하자 <br />

특히나 테스트 러너와 같은 도구를 사용할 때가 그러한데, jest 같은 경우 각 테스트 파일은 고유한 자식 프로세스에서 실행이 된다. 이는 사실상 모든 테스트 파일이 모듈 그래프를 처음부터 다시 구성하고 그에 대한 비용을 지불해야 한다는 것이다. 만일 프로젝트에서 모듈 그래프를 구성하는데 6초가 걸리고 테스트 파일이 100개만 있다고 가정해도 총 6 \* 100초 로서 10분이 낭비가 된다. 테스트가 실행되는게 10분이 아니라 10분이 지난 후에야 테스트가 진행이 된다는 의미이다.

### 최선은?

빌드를 통해 단일 파일로의 번들링된다면 베럴 파일에 대한 문제가 해소될 수 있겠으나, 테스트 환경과 같은 경우는 문제가 될 수 있기에 매 폴더마다 배럴 파일을 사용하는것은 지양하는것이 좋겠다.
