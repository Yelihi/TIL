## 캐시 무효화

<p>만약 어떤 페이지는 절대로 캐시화를 하면 안된다고 한다면, 밑 에서 적어둔 부분을 모두 헤더에 넣어야 한다.</p>

- Cache-Control: no-cache, no-store, must-revalidate
- Pragma: no-cache

<p>위 캐시 지시어에 대해 다시 살펴보자</p>

- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용(이름에 주의!!)
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨
  - 메모리에서 사용하고 최대한 빨리 삭제
- Cache-Control: must-revalidate
  - 캐시 만료후 최초 조회시 원 서버에 검증해야함
  - 원 서버 접근 실패시 반드시 오류가 발생해야함 -504(Gateway Timeout)
  - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
- Pragma: no-cache
  - HTTP 1.0 하위호환

### no-cache vs must-revalidate

<p>둘다 비슷해 보이지만 크게 차이점이 존재하는데, 바로 프록시 서버와 원 서버 사이의 네트워크 오류시에 발생하게 된다. 우선 no-cache 나 must-revalidate 의 기본적인 흐름을 살펴보자</p>

- ETag + noCache -> 프록시 서버 전달(noCache 니 원서버로 전달) -> 원서버 검증
- 검증 후 응답 (예로 Not Modified)
- 클라이언트는 이를 받고 기존 캐시 사용

<p>이 과정은 동일하나 만약 위에서 언급했듯이 프록시 서버와 원 서버간의 에러가 발생했다고 가정하겠다. 즉 검증을 받을 수 없는 상황인 것이다. no-cache 라고 가정하겠다</p>

- 원 서버로 접근이 안됨
- 프록시 서버는 어쩔 수 없이 기존 캐시화면이라도 보여주자 하고 캐시를 보내게됨 (200 OK)
- 클라이언트는 이 캐시를 받게 된다.

<p>이러한 문제를 해결하기 위해 must-revalidate를 사용하게 된다. 이걸 사용하면 만일 원서버의 접근이 에러가 발생한다면 504 오류를 보내게 된다.</p>

- 원 서버로 접근이 안됨
- 즉시 504 에러를 보내준다.
- 클라이언트는 에러 페이지를 띄우게 된다.

<p>하나의 예시로 만일 통장 잔고 페이지를 띄어야 한다고 생각해보자. 이 페이지는 캐시화되서는 안된다. 만일 누군가에게 송금을 하고 나머지 잔액화면을 띄어야 하는데, 기존 캐시화면을 띄우면 큰일이다.</p><br />
<p>이런 경우 만일 no-cache 사용 시 돈을 송금했는데, 원서버의 에러를 통해 프록시서버에서 기존 캐시화면을 대신 보내주고 이를 클라이언트가 랜더링 하면 돈이 그대로 남아있는식으로 되어있을 것이다. 이렇기 때문에 504 페이지가 보이도록 조치를 해주어야 한다.</p>
