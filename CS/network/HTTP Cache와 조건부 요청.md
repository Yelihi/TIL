## HTTP 헤더의 캐시와 조건부 요청

### 캐시가 없을때

<p>예를 들어서 브라우저에서 이미지를 서버에 요청한 뒤, 응답으로 메시지와 함께 이미지를 받아온다고 가정해보자. 메시지가 대략 0.1mb 라고 가정하고 이미지가 1.0mb 라고 가정했을 때, 매 요청때마다 응답을 받으면 1.1mb 씩 가져와야 한다. 당연히 예상할 수 있겠지만, 계속된 데이터 다운은 로딩 속도의 저하를 가져오게 된다.</p>

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다
- 인터넷 네트워크는 매우 느리고 비싸다
- 브라우저 로딩 속도가 느리다
- 느린 사용자 경험

### 캐시 적용

```
HTTP/1.1 200 OK
Content-Type: image/jpeg
cache-control: max-age=60
Content-Length: 34012

```

- 캐시가 적용될 경우 `cache-control` 이라는 응답이 같이 가게 되는데, value 값은 캐시가 유요한 시간(초)를 보낼 수 있다. 60이라면 60초 동안은 캐시가 유효하다 라는 의미이다.
- 웹 브라우저에는 캐시 저장소가 있다. 응답 결과를 캐시 저장소에 저장한다
- 두번째 요청에서는 먼저 요청보내기 전에 캐시저장소를 먼저 살펴보게 된다. 있다면 그대로 가져다 쓴다
- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다
- 비싼 네트워크 사용량을 줄일 수 있다
- 브라우저 로딩 속도가 매우 빠르다
- 빠른 사용자 경험

### 캐시 시간 초과

<p>만약 세번쩨 요청에서 캐시 유효시간이 지난 상태라면 다시 응답을 받아야 한다. 왜냐하면 데이터가 fresh 하지 않을 수 있기 때문이다. 하지만 만약 변화가 없는 파일이라면, 여전히 계속 네트워크 손실이 이루어지는것이기에 이를 해결할 방안을 고려해야 한다.</p><br />

### 검증 헤더와 조건부 요청

<p>기본적으로 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 발생</p>

- 서버에서 기존 데이터를 변경함
- 서버에서 기존 데이터를 변경하지 않음 (이 경우가 아까움)

<p>이러한 문제를 해결하기 위해 검증 헤더가 사용된다</p>

```
HTTP/1.1 200 OK
Content-type: image/jpeg
cache-control: max-age=60
Last-Modified: 2020년 11월 10일 10:00:00 (실제로는 한글 아니다)
...

```

- 또 새로운 부분이 추가 되었다. `Last-Modified`
- 이 속성을 통해서 언제 최종적으로 이 파일이 업데이트 되었는지 확인할 수 있다.
- 캐시 저장소에 이 부분을 같이 저장해놓는다.
- 60초가 지난 뒤, 다시 서버에 요청을 보낼 때 캐시 저장소에 데이터 최종 수정일이 있다면 같이 보낸다.

```
GET /star.jpg
if-modified-since: 2020년 11월 10일 10:00:00

```

- 서버에서는 이 날짜를 보고 판단을 하게 된다. 데이터가 수정이 안되었다면

```
HTTp/1.1 304 Not Modified
Content-Type: Image/jpeg
cache-control: max-age=60
Last-Modified: 2020년...

```

- 이렇게 body 부분을 없에고 메시지만 응답으로 보내게 된다.
- 브라우저는 이러한 응답을 보고 캐시 안 내용을 그대로 사용해도 되겠구나 판단하고
- 캐시 데이터를 그대로 사용하게 된다. (캐시의 메타 정보를 갱신하고 캐시 데이터 재활용)
- 실제 개발자도구에서 네트워크 창에 보면 그 색이 연한 파일이 있고 진한 파일이 있는데, 연한 파일이 캐시해서 불러온 데이터이다.

<p>이제 전반적으로 검증 헤더를 정리해보자</p>

- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - Last-Modiried, ETtag
- 조건부 요청 헤더
  - 검증 헤더로 조건에 따른 분기
  - If-Modified-Since: Last-Modified 사용
  - If-None-Match : Etag 사용
  - 조건이 만족하면 200 Ok
  - 조건이 만족하지 않으면 304 Not Modified
- 데이터 미변경 시
  - 304 Not Modified, 헤더 데이터만 전송(Body 미포함)
  - 전송 용량에 바디 제외
- 데이터 변경 예시
  - 200 Ok, 모든 데이터 전송(Body 포함)
  - 전송 용량 전부

### Last-Modified의 단점

- 1초 미만 단위로 캐시 조정이 불가능
- 날짜 기반의 로직 사용
  - a -> b 로 변경하고 다시 b -> a 로 변경하였을 때는, 실제 컨텐츠 a 가 그대로이다.
  - 하지만 날짜는 변경되어있다. 그렇게 되면 데이터 a 를 다시 다운로드 하게 된다.
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우가 힘들다
  - 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

### ETag, If-None-Match

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
  - ex) ETag: 'v1.0'
- 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
  - ex) Etag: 'v1.0' -> 'v2.0'
- 정말 단순하게 ETage 가 다르면 다시 요청

```
HTTP/1.1 200 OK
Content-Type: Image/jpeg
cache-control: max-age=60
ETag: "aaaaa"
...
```

- 위 처럼 서버에서 브라우저에 ETag 값을 같이 준다.
- 60초가 지난 뒤, 요청에 다음과 같이 전송을 한다

```
GET /star.jpg
If-None-Match: 'aaaaa'

```

- 서버가 가진 ETag 와 브라우저가 보낸 ETag 를 비교해봐서 변화가 없다면 304 를 보내게 된다
- 바뀐게 있다면 200을 보내게 된다.
- 304를 받았다면, 브라우저는 캐시를 갱신하게 되고, 데이터를 캐시에서 조회를 한다.
- 이러한 방법의 장점은 캐시 제어 로직을 서버에서 완전하게 관리할 수 있다는 점에 있다.
- 날짜가 아니기에 설사 변경을 하였다고 하더라도 ETag 를 그대로 유지한다면, 브라우저는 캐시 데이터를 활용하게 될 것이다.

### Cache-Control: 캐시지시어

- Cache-Control: max-age
  - 캐시 유효 시간, 초 단위
- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
  - 원서버 검증이란 중간캐시서버에서 작업하지말고 마지막 원서버까지 가서 검증하라는 의미
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨

### Pragma

- Pragma: no-cache (지금은 거의 사용 안함)

### Expire

- 캐시만료일을 지정할 수 있다.
- 캐시 만료일을 정확한 날찌로 지정
- HTTP 1.0부터 사용
- 지금은 더 유연한 Cache-Control 을 사용한다.
