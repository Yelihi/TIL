## 모든것이 HTTP

### HTTP

- HTTP 는 HyperText Transfer Protocol 의 약자
- 현재는 거의 모든 형태의 데이터를 다 전송할 수 있다.
- 서버간에 데이터를 주고 받을때도 거진 HTTP 를 활용해서 전송한다.

### HTTP의 역사

- HTTP/0.9 : 1991년 GET 메서드만 지원, HTTP 헤더없음
- HTTP/1.0 : 1996년 메서드와 헤더가 추가됨
- HTTP/1.1 : 1997년 가장 많이 사용, 우리에게 중요한 버전
- HTTP/2.0 : 2015년 성능 개선
- HTTP/3.0 : TCP 대신에 UDP 사용, 성능 개선
  <br/>

- 참고로 1.1 에 대부분의 기능이 다 들어있고 이후 버전은 성능의 개선에 초점이 맞춰져 있다.
- 실제로 크롬 개발자도구에서 확인이 가능한데, 네크워크 창에서 프로토콜을 확인할 수 있다. h2 = http2, h3 = http3 이런식으로 확인이 가능하다.

### HTTP 특징

- 클라이언트 서버 구조
- 무상태 프로토콜, 비연결성
- HTTP 메세지
- 단순하고 확장이 가능하다

> **클라이언트 서버 구조**

- 클라이언트가 서버에 요청을 보내고, 서버가 응답을 보내면 그 응답 결과에 따라 클라이언트가 동작하게 된다.
- 당연한 이야기 같지만 사실 이렇게 클라이언트와 서버를 개념적으로 분리하고, 비즈니스로직 및 데이터로직을 서버에 집중시키고, 클라이언트는 사용성이나 UI에 집중을 한다.
- 이렇게 되면 좋은점이 각자 독립적으로 성능을 증가시킬 수 있다.

> **무상태 프로토콜(stateless)**

- 서버가 클라이언트의 상태를 보존하지 않는다는 의미다.
- 이 말은 이전 상태의 문맥을 보존하지 않는다는 것. 예시를 통해 한번 살펴보는게 좋다.
  <br />

- 예를 들어 애플 가게에서 맥북을 구매하는 상황을 살펴보자

  - 고객 : 노트북 구매할꼐요
  - 점원A : 노트북 한대는 200만원입니다.

  - 고객 : 2개 구매할꼐요
  - 점원B: ? 무엇을 2개 구매하나요

  - 고객 : 신용카드로 할께요
  - 점원C : ? 무엇을 몇개 신용카드로 구매하나요
    <br />

- 이처럼 만일 상태가 유지되는 상태라고 한다면 점원이 바뀌게 되면 그 상태유지가 이어지질 않아서 문제가 발생하게 된다.
- 이 점원을 서버로 치환하면, 만일 기존 서버가 문제가 발생하였다면 유지되고 있던 상태값이 전달이 되질 않아, 다른 서버에서 이를 해결하기가 어려워진다.
- 반면 무상태를 유지한다는 것은 매 연결마다 모든 정보를 다 담고 있다는 의미이다.
  <br />

- 같은 예시로 애플 가게에서 맥북을 구매하는 상황이다.

  - 고객: 노트북 구매할께요
  - 점원A: 한대당 200만원입니다.

  - 고객 : 노트북 2대 구매할께요
  - 점원B : 2대이니 400만원입니다.

  - 고객 : 노트북 2대 신용카드로 구매할께요
  - 점원C : 네 알겠습니다.
    <br />

- 이렇게 매 전달 때마다 완성된 정보를 전달하기에, 어떤 점원이 처리해도 다 응답이 가능해진다
- 즉, 어떤 서버가 처리한다고 해도 처리가 가능해지기 때문에, 서버를 무한정으로 확장시켜도 아무런 문제가 발생하지 않게 된다.
- 이렇기 때문에 무상태라는 것은 아주 중요한 패러다임이다.
- 다만, 로그인 같은 상태가 유지되어야 하는 상황이 있고, 이에 따라 쿠키세션으로 상태 유지하는 방법이 있다.
- 결론은 최대한 무상태를 유지하는것이 바람직하다는 것이다.

> **비연결성**

- HTTP 는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 1시간동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음. 왜냐면 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않기 때문
- 서버 자원을 매우 효율적으로 사용할 수 있음

> **비연결성의 단점**

- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간이 추가된다.
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함꼐 다운로드
- 이게 왜 문제냐면 만일 하나의 검색어를 검색했을 때, 서버에 요청하는 부분이 html 뿐이 아니라면 어떨까
- 연결을 유지하지 않기 때문에, html 요청, 자바스크립트 요청, css 요청, 이미지 요청 등등 모든 각각의 요청마다 연결을 다시 걸어야 하고 이건 3 way handshake 과정을 계속 거친다는 의미이다.
- 비효율적일 수밖에 없기 때문에 지금은 HTTP 에서 지속 연결(Persistent Connections)로 해결하고 있다.
- 지속 연결은 우선 연결을 처음 하고, 내부 매커니즘에 따라 몇 초간 연결을 유지한다는 식으로 지속적으로 연결을 해서 요청과 응답 세트를 계속해서 받는다. 그래서 위 문제를 해결했다
- HTTP/2, HTTP/3 에서는 더 성능이 확장되었다.

> **스테이스리스를 기억하자**

- 선착순 이벤트나 명절 KTX 예약 등은 비연결성의 장점이 모두 사라진다.
- 즉 한 순간에 엄청난 트래픽이 몰리기 때문이다.
- 방법이라면 어떻게든 스테이스리스를 유지하는 쪽으로 설계헤야 한다.

### HTTP 메세지

- HTTP 메세지의 구조는 아래와 같다.

```
star-line : 시작라인
header: 헤더
empty line: 공백 라인(CRLF)
message body
```

> **시작라인**

- 우선 요청 메시지
- 시작라인은 request-line / status-line 으로 구성이 된다.
- request-line 의 경우 method request-target HTTP-version
- 메서드는 종류로는 뭐 GET, POST, PUT, DELETE...
- 즉 서버가 수행해야 할 동작 지정
- 요청 메세지는 보통 절대 경로가 들어가고("/" 으로 시작하는)
  <br />

- 다음은 응답 메세지
- 시작 라인은 status-line 이며
- status-line 은 HTTP-version status-code reason-phrase 로 구성된다.

> **헤더**

- HTTP 전송에 필요한 모든 부가정보가 들어가있다.
- 예시로 메시지 바디의 내용, 메시지 바디 크기, 압축 됬는지, 인증정보, 요청 클라이언트 정보, 캐시 관리 정보 등등...
- 즉 필요한 메타 데이타가 다 들어가있다 생각하자

> **HTTP 메시지 바디**

- 실제 전송할 HTML, 이미지, 영상 등 데이터가 들어간다.
