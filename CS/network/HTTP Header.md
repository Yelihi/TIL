### HTTP 일반 헤더

> **용도**

- HTTP 전송에 필요한 모든 부가정보
  - 메세지바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시관리정보...
- 표준 헤더가 너무 많음 + 필요시 임의의 헤더 추가 가능

> **분류(HTTP 헤더): 1999년 RFC2616**

- General 헤더 : 메세지 전체에 적용되는 정보 ex) Connection: close
- Request 헤더 : 요청 정보, ex) User-Agent: Mozilla/5.0 (Macintosh)
- Response 헤더 : 응답 정보, ex) Server: Apache
- Entity 헤더 : 엔티티 바디 정보, ex) Content-Type: text/html, Content-length:..
  - 엔티티 헤더는 엔티티 본문(메시지본문)의 데이터를 해석할 수 있는 정보 제공
  - 데이터 유형, 데이터길이, 압축정보

<p>개정판이 나오게 되고 RFC2616 이 폐기가 된다. 엔티티라는 용어 대신 표현(Representation)이라는 용어가 생겨남. 표현 = 표현의 메타데이터 + 표현 데이터</p>

> **분류: 2014년 RFC7230**

- 표현 헤더, 표현 데이터로 구성
- 메시지 본문(message body)를 통해 표현 데이터를 전달
- 메시지 본문 = 페이로드(payload)
- 표현은 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
  - 데이터 유형, 데이터 길이, 압축정보

### 표현

<p>전송하고자 하는 어떠한 정보를 html이나 json 이라는 데이터형식(표현)으로 전달하고자 한다면, 이러한 리소스를 데이터 형식으로 표현한다 라고 말할 수 있다.</p>

- Content-Type: 표현 데이터의 형식
  - body 에 들어가는 형식이 무엇인지
  - text/html, applacation/json, image
- Content-Encoding: 표현 데이터의 압축 방식
  - 데이터를 우선 압축 한 뒤, 응답쪽에서 무엇으로 압축했는지 알려준다.
- Content-Language: 표현 데이터의 자연 언어
  - ko, en.. 등등의 자연언어
  - 홈페이지에서 언어 바꾸기 등등할떄 사용할 수 있다.
- Content-Length: 표현 데이터의 길이
  - 바이트 단위

### 콘텐츠 협상 : 클라이언트가 선호하는 표현 요청

<p>클라이언트가 선호하는 표현 방식을 서버에게 요청한다고 생각하면 된다.</p>

- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accpet-Language: 클라이언트가 선호하는 자연언어

<p>클라이언트는 한국어 브라우저를 사용하고 있고, 서버는 기본언어로 영어로 체택한다고 해보자. 서버의 상황에 따라 다르겠지만, 만약 서버측에서 한국어를 지원한다고 가정한다면, 클라이언트에서 accept-language 를 ko 로 설정함으로서 서버에서는 이를 확인하고 한국어로 보내게 된다.</p><br />

<p>그런데 생각해보면 한국어대신 독일어를 지원할 수 있고, 독일어를 기본언어로 셋팅해두었을 수도 있다. 이런 경우 협상의 우선순위를 매기면 그나마 최선인 영어를 가져오는것이 가능하다.</p>

- 서버는 독일어와 영어 버전을 제공한다
- 브라우저는 한국어 전용이지만, 그나마 2순위로 영어를 원한다.
- 이때 우선순위가 적용된다.

> **Quality Values(q)**

- 0~1 사이로서 1에 가까울수록 우선순위가 크다.
- q를 생략하면 1이다.
- ex) Accept-Language: ko-KR, ko;q=0.9, en-US;q=0.8, en;q=0.7
- 이렇게 보내게 된다면, 한국어가 가장 최우선이며 그다음이 영어임을 서버가 알게된다.
- 그렇기에 영어를 보내게 된다.
- 구체적일 수록 우선순위가 높다
- ex) `text/*;q=0.3`, `text/html;q=0.7`, `text/html;level=1`, `text/html;level=2;q=0.4`, `*/*;q=0.5`
  - 위 예제처럼 처리된 경우 미디어 타입을 예로 들어보면
    |mediatype|quality|
    |---------|-------|
    |text/html;level=1|1|
    |text/html|0.7|
    |text/plain|0.3|
    |image/jpeg|0.5|
  - 이런식으로 구성이 된다.

### 전송 방식

- 단순 전송
  - 컨텐츠 길이를 알 수 있을 때 응답을 그대로 받는다. 그 컨텐츠만큼
- 압축 전송
  - gzip 같은 걸로 압축을 한뒤, Content-Encoding 정보를 같이 보내준다
- 분할 전송
  - Transfer-Encoding: chunked 를 통해서 데이터를 일정 바이트 기준으로 나눠서 보낸다.
  - 용량이 너무 커서 한번에 쭉 보내기 힘들어서 나눠서 보내는 방식
  - Content-Length 를 넣을수가 없다.
- 범위 전송
  - 예를 들어 사진을 받아오는데, 중간에 연결이 끊켜서 파일이 절반까지밖에 오지 않았다면
  - 클라이언트는 서버에게 나머지 부분만을 범위지어서 요청할 수 있다.

### 일반 정보

- From : 유저 에이전트의 이메일 정보
  - 일반적으로 잘 사용되지 않음
  - 검색 엔진 같은 곳에서, 주로 사용
  - 요청에서 사용
- Referer: 이전 웹 페이지 주소
  - 현재 요청된 페이지의 이전 웹페이지 주소
  - 구글에서 hello 를 입력해서, 위키피디아에 들어가면(위키백과 들어가는 요청)
  - 이때 개발자도구에서 referer 를 보게되면, www.google.com 으로 되어있다.
  - 즉 이전 단계의 요청 주소를 나타낸다.
  - 이를 통해 유입 경로를 분석할때 가능하다
  - 요청에서 사용한다
  - 참고로 원래 referer 는 referrer 의 오타이다.
- User-Agent: 유저 에이전트 애플리케이션 정보
  - 클라이언트의 애플리케이션 정보
  - 예를 들어 특정 브라우저에서 오류가 발생할 때 사용하기 좋다
  - 통계 정보
  - 요청에서 사용
- Server : 요청을 처리하는 Origin 서버의 소프트웨어 정보
  - 진짜 나의 요청이 있는 마지막 서버를 origin 서버라 한다.
- Date : 메시지가 발생한 날짜와 시간
  - 응답에서만 사용

### 특별한 정보

- Host: 요청한 호스트 정보(도메인)
  - 요청에서 사용하면서 필수값이다.
  - 하나의 서버가 여러 도메인을 처리해야할 때
  - 예를 들어 200.200.xx 의 서버에 여러 도메인을 처리할 수 있다고 가정하자.
  - 클라이언트에서 호스트 없이 요청을 보내면, 서버에서는 어디 도메인에 이 요청을 보내야할지 알 수가 없었다.
  - 결국 호스트를 넣어주는 것이 스펙이 들어가게 되었다.
  - TCP 는 IP 간의 통신이니, 호스트가 필수적으로 필요하다.
- Location : 페이지 리다이렉션
  - 웹 브라우저는 300대 응답에 따라 Location 헤더가 있으면 자동 리다이렉트 하게 된다.
  - 201의 경우 Location 값은 생성된 URI
- Allow : 허용 가능한 HTTP 메서드
  - 405 (Method Not Allowed) 에서 응답에 포함해야 함
  - 사실 많이 구현되어있지 않다.
- Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  - 503 (Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음

### 인증

- Authorization: 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의
  - 인증을 하기위한 필요한 정보를 알려준다
  - 401 Unauthorized 응답과 함꼐 사용

### 쿠키

- Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
- Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

<p>HTTP 는 무상태(Stateless) 프로토콜이다. 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다. 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 않는다. 이러한 문제를 해결하기 위해 쿠기가 도입되게 된다.</p>

> **쿠키의 생명주기**

- 만료일이 되면 쿠키가 자동으로 삭제한다
- 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지
- 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지

> **쿠키 도메인**

- 명시한 도메인에 쿠키를 전송한다.

> **쿠키 경로**

- 경로를 넣으면 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
- 보통은 path =/ 루트 지정 (왠만하면 다 넘겨준다)

> **쿠키 - 보안**

- Secure 을 넣으면 https 에만 전송하게 된다.
- HttpOnly 는 XSS 공격을 방지하는 것으로 이걸 설정해주면 자바스크립트에서 접근이 불가능해진다.
- SameSite 는 XSRF 공격을 방지한다. 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송
