<h2 align="center"> Network </h1>
<h3 align="center"> 매일 공부한 부분을 간략하게 정리하자 </h3> 
<br />

<h2 id="프로젝트소개"> :book: 작성일 기록 </h2>

- [2023.1.17](#2023-1-17)
- [2023.1.18](#2023-1-18)
- [2023.1.21](#2023-1-21)
- [2023.1.22](#2023-1-22)
- [2023.1.26](#2023-1-26)

  <br />

![--------------------------------------------------------](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<h2 id="프로젝트소개"> :book: 간단한 요약 정리 </h2>

## 2023-1-17

### REST API 보안

<p>근래 대부분의 서비스는 API 를 기반으로 통신한다. 이에 따라 API 보안 역시 중요하다.</p>

### 인증(Authentication)

- 인증은 누가 서비스를 사용하는지 확인하는 절차
- 즉 아이디와 패스워드를 기입하여 사용자를 확인하게 된다.
- API 역시 마찬가지인데, API 를 호출하는 대상이 서버인지 사용자가 되었던지 결국 누구인지 확인하는 절차가 필요하다.

### 인가(Authorization)

- 인가는 해당 리소스에 대해 사용자가 그 리소스를 사용한 권리가 있는지 확인하는 체크 과정
- 로그인한 사람만(인증된 사람) 프로필 페이지를 사용할 수 있거나, 주문을 할 수 있는 등

### 네트워크 레벨 암호화

- 인증과 인가 과정이 끝나서 API 를 호출하게 되면, 네트워크를 통해서 데이터가 오가는데 이때 해커가 중간에서 이 통신을 감청할 수 없게 할 필요가 있다.
- 이에 네트워크 프로토콜단에서 암호화를 처리할 수 있는데, 이를 네트워크 암호화라고 한다. HTTP 기반에서의 네트워크 암호화는 일반적으로 HTTPS 기반의 프로토콜을 사용한다.

### 인증(Authentication) 방식의 종류

<p>API에 대한 인증 방식은 여러가지 방식이 있고, 보안수준과 구현수준이 다르기 때문에 구현하고자 하는 서비스의 특성을 살려서 적절한 API 인증 방식을 선택하여야 한다.</p>

> **API 키 방식**

- API key : 특정 사용자만 알수 있는 일종의 문자열.
- API를 호출하고자 할 때, 개발자는 API 제공사의 포탈 페이지에서 API 키를 발급 받고 API를 호출 할 때 API 키를 메세지 안에 넣는다. 서버는 메시지 안 API 키를 읽어서 누가 호출한 것인지 파악한다.
- 모든 클라이언트가 같은 key 를 공유하기에, 한번 key 가 노출되면 모든 API가 보안에서 취약해지기 때문에 높은 보안 인증이 필요할 때는 하지 않는다.

> **API 토큰**

- 사용자의 아이디와 비밀번호를 인증한 다음, 서버에서 일정 기간 유효한 토큰을 발급하는 방식이다.
- 매번 API 호출 시 아이디와 비밀번호를 보내지 않고 API 토큰을 사용하는 이유는 사용자와 비밀번호는 주기적으로 바뀔 수 있기 때문이고, 매번 네트워크를 통해서 사용자 ID와 비밀번호를 보내는 것은 보안상 계정 정보를 탈취당할 가능성이 크기 때문.

### Claim 기반은 JWT 방식

> **Claim 기반 토큰의 개념**

- 보통 token 의 경우 특별한 정보를 가지고 있지 않는다.
- 하지만 JWT는 Claim 기반이라는 방식을 사용하는데, Claim 은 사용자에 대한 프로퍼티나 속성을 말한다.

```js
{
  "id: "won",
  "role": "admin",
  "company": "pepsi",
}
```

- 이 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰 안에 다 들어가 있기 때문에, 다른 곳에서 가져올 필요가 없다는 장점이 있다.
- 결과적으로 토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없다. 서버 입장에서는 API 요청을 검증하기 위해 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다는 것.
- JWT 는 JSON Claim을 Base 64로 인코딩하여 HTTP 헤더에 쉽게 넣을 수 있다.

> **JWT 의 단점**

- Claim 에 넣는 데이터가 많아질수록 토큰 길이가 길어진다. 헤더에 붙여서 보내기 때문에 길이가 길어진다는 것은 네트워크 대역폭 낭비가 심하다는 의미.
- 한번 발급된 토큰은 수정하거나 폐기가 불가능하다. 그렇기 때문에 만료 시간을 꼭 명시하고 중간마다 토큰을 재 발행하여야 한다.
- 기본적으로 JWT 는 Claim 에 대한 정보를 암호화 하지는 않는다.

---

### 인터넷에서 통신을 하는 방법

> **IP**

- 우선 인터넷 프로토콜(IP) 에 대해서 알아야 한다.
- 인터넷 프로토콜의 역할은 지정된 IP 주소에 데이터를 전달하고, 패킷(Packet)이라는 통신 단위로 데이터를 전달
- IP 패킷에는 규칙이 있는데, 나의 IP(출발지), 목적지 IP, 전달 메세지 를 패킷에 넣고 전달한다.
- 목적지에서 패킷을 잘 받았다면, 반대로 목적지에서도 확인되었다는 패킷을 만들어서 클라이언트인 나에게 전달한다.
- 다만 한계가 있다. 패킷을 받을 대상이 없거나 서비스가 불능이라도 나는 패킷을 전송하게 된다. 응답이 없을 뿐. 즉, 받을 상태인지를 알 수가 없다.
- 인터넷망에서 전달한 패킷이 사라질수도 있고, 순서대로 도착하지 않을 수도 있다.
- 이런 문제들을 해결해주는 것이 TCP, UDP 이다.

> **TCP란**

- IP 프로토콜에서 발생하는 문제들을 해결해준다.
- 프로토콜에는 계층이 있다. 보통 OSI 7 Layer 를 들어봤을 것인데, 여기에 집중하지말고 우리가 파악하기 쉽게 해석하자면 크게 어플리케이션, OS, 네트워크 인터페이스로 구별된다 생각하자.
- 어플리케이션 : 우리가 사용하는 인터넷 등 프로그램과 SOCKET 라이브러리
- OS : TCD -> IP
- 네트워크 인터페이스 : LAN 드라이버, LAN 장비

<p>채팅 어플리케이션에서 hello 를 전달한다고 가정해보자</p>

- 어플리케이션에서 hello 메시지를 생성한다
- 이후 SOCKET 라이브러리를 통해 전달한다
- TCP 정보가 생성이되어 TCP 패킷을 통해 메시지를 감싼다
- 이후 IP 패킷이 생성되어 감싼다 (현재 TCP, IP 패킷 포함)
- LAN 카드에 의해 이더넷프레임을 씌어 전달한다.

<p>TCP에는 출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증정보... 등등 포함된다.이러한 TCP 의 특징은 다음과 같다.</p>

- 전송 제어 프로토콜(Transmission Control Protocol)
- 연결 지향: TCP 3 way handshake(가상 연결)
- 데이터 전달 보증
- 순서 보장

> **TCP 3 way handwhake**

- 우선 클라이언트에서 서버로 syn(싱크로나이즈) 라는 메시지를 보낸다.
- 서버에서는 syn 를 받고 확인한 다음 클라이언트에 ack 를 같이 클라이언트에 보낸다.
- 클라이언트는 ack 를 받고 확인한 뒤 ack 를 서버에 전달한다.
- 이렇게 3번 주고받으면서 클라이언트와 서버가 서로 신뢰할 수 있게 된다.
- 이제 연결이 된걸 확인했으니 그 다음에 데이터를 전송한다.
- 허나 주의할점이 있다. 클라이언트에서 서버까지 가는 과정에 수많은 서버들이 존재하는데, 이 모든 과정에 대한 연결 보장을 이야기하는것이 아니다. 그저 클라이언트와 서버간 연결이 되었구나 하고 생각하자. 즉 물리적 연결은 아니다.

> **데이터 전달 보증**

- 데이터를 전송했다면, 서버에서 데이터를 받았다는 확인 메세지를 전송한다.

> **순서 보장**

- 클라이언트에서 순서대로 패킷을 보내도, 서버에 패킷이 도착했을 때 순서가 잘못되어있다면 서버에서 다시 보내라고 신호를 보낸다.
- 이게 가능한 이유는 TCP 안에는 전송제어 정보, 순서 등등의 정보가 담겨져 있기 때문이다.

> **UDP**

- 사용자 데이터그램 프로토콜(User Datagram Protocol)
- UDP는 기능이 거의 없다. IP 와 비슷한데 추가된 부분은 PORT 부분이 있다.
- PORT 는 하나의 IP 를 사용하는 클라이언트가 여러가지 어플리케이션을 활용할 때, 각 어플리케이션 마다 서버에서 응답받는 패킷이 오게 될 것이고, 이를 구별하기 위해 사용하게 된다.
- 현재 인터넷 환경 자체는 TCP 가 다 먹고 있으며, 이제 건들수가 없다.
- 이 때 UDP 는 하얀 도화지로 비유가 되곤 하는데, 이 말은 이제 어떠한 새로운 기능이나 커스터마이징이 필요할 떄 UDP 를 사용할 수 있다는 것이고, 앞서서 설명한 TCP 의 3 way 방식등의 절차역시 없기에 속도 자체가 빠르다. 데이터 역시 적게 든다.
- 최근에는 hTTP3 에서 UDP 를 좀 더 활용해보고자 하고 있기에 주목받고 있다.

> **PORT**

- 우리가 게임도 하면서 화상통화도 하고 웹브라우저도 한다고 한다면, 하나의 클라이언트가 여러개의 서버와 연결을 해야한다.
- 패킷을 보낼때나 받을 때의 경우 이를 어떻게 구별할지에 대한 고민이 생겼다.
- TCP 패킷을 보게 되면 출발지 port 가 있고, 목적지 port 정보가 같이 들어간다.
- 이 port 를 통해서 패킷이 구별이 가능해진다.
- 비유를 하자면 Ip 가 아파트라면 port 는 동 호수라고 생각하자
- 기본적으로 0~65535 번까지 할당이 가능하지만, 0~1023 까지는 잘 알려진 포트라 사용하지 않는것이 좋다.

> **DNS**

- 우리가 IP 를 사용해서 통신을 할 때, IP를 매번 기억하는경우나, IP 가 중간에 변경되는 경우가 발생하면 문제가 된다.
- 이를 해결하기 위해 도메인(Domain Name System)을 사용할 수 있다.
- 우리가 구글에 접속하는 과정을 생각해보면 도메인이 어떻게 사용되는지 확인할 수 있다.
- www.google.com 을 입력하게 되면 DNS 서버에 전송이 되어 DNS 서버에서는 이 도메인에 맞는 IP 주소를 응답한다.
- IP 주소가 왔으니, 이제 이전 통신과정과 같다.

## 2023-1-18

### URI

> **URI**

- URI(Uniform Resource Identifier) 라는 리소스를 식별하는(주민번호로 사람을 식별 하는 것과같은) 가장 큰 개념이 있다.
- 이 URI 는 집합관계에서 URL 과 URN 을 감싸고 있다.
- URL(Resource Locator)(리소스의 위치를 지정) 과 URN(Resource Name)(리소스의 이름)
- 대부분 URL 만 쓴다. 그래서 그냥 URI 를 URL 로 파악하면 된다.
- 다시 넘어가 URI 를 살펴보면
- Uniform : 리소스 식별하는 통일된 방식
- Resource : 자원, URI로 식별할 수 있는 모든 것(제한없음)
- Identifier : 다른 항목과 구분하는데 필요한 정보

```
http://www.google.com/search?q=hello&hl=ko
```

- 위 URL 형태를 보게 되면 아래와 같이 구성됨을 알 수 있다.
- scheme://[userinfo@]host[:port]/[/path][?query][#fragment]

> **scheme**

- scheme 에는 주로 프로토콜을 사용한다. 프로토콜이란 어떤 방식으로 자원에 접근할 것인가에 대한 약속이자 규칙이다.
- http는 80 포트, https 는 443 포트를 사용하며, 이렇기에 생략이 가능하다.

> **userinfo**

- 거의 사용하지는 않음.

> **host**

- 호스트명
- 도메인명 또는 IP 주소를 직접 사용 가능하다.

> **host**

- 접속 포트이며 일반적으로 생략이 가능하다. 생략시 http는 80. https 는 443 이다.

> **path**

- 리소스의 경로이며 계층적인 구조가 많다
- /home/members/100 (100번에 있는 회원의 정보) -> 이런식으로 계층적으로 설계되는 경우가 많다.

> **query**

- key=value 형태이며 ?로 시작한다. &으로 추가가 가능하다. ?keyA=valueA&keyB=valueB

> **fragment**

- html 내부 북마크 등에서 사용하며 서버에 전송하는 정보는 아니다.

### 웹 브라우저 요청 흐름

- 앞서 다뤘던 구글 검색 URL 을 다시 참고해보자

```
https://www.google.com/search?q=hello&hl=ko
```

- 웹 브라우저는 구글이라는 도메인 네임을 DNS 서버에서 조회를 해서 서버 IP 를 가져온다. 또한 https 를 통해 생략된 포트 443 역시 가져온다
- 이 다음 http 요청 메세지를 생성한다. 이 메세지를 간략히 적으면 아래와 같다.

```
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
```

- SOCKET 라이브러리를 통해 생성한 메세지를 os 의 TCP/IP와 연결한다.
- 처음 과정은 앞에서 배웠듯이 syn,ack 과정인 3 way handshake 과정을 통해 통신하려는 서버와 연결할 수 있는지 확인을 한다.
- 이후 확인이 됬으면 TCP/IP 에서 패킷을 생성하여 메세지에 첨부한다. (이때 메세지에 아까 브라우저에서 만든 요청 메세지)
- 서버가 이 요청 패킷을 받게 되면, 메세지를 해석하게 되며 그에대한 응답 메세지를 만들게 된다.
- 이후 똑같이 패킷에 씌어서 이 응답메세지를 브라우저에 보내주게 된다.
- 컨텐츠에 따라 다르겠지만, 보통은 html 문서가 오기 때문에, 브라우저는 이 html 을 렌더링 하게 된다.

## 2023-1-21

### 모든것이 HTTP

> **HTTP**

- HTTP 는 HyperText Transfer Protocol 의 약자
- 현재는 거의 모든 형태의 데이터를 다 전송할 수 있다.
- 서버간에 데이터를 주고 받을때도 거진 HTTP 를 활용해서 전송한다.

> **HTTP의 역사**

- HTTP/0.9 : 1991년 GET 메서드만 지원, HTTP 헤더없음
- HTTP/1.0 : 1996년 메서드와 헤더가 추가됨
- HTTP/1.1 : 1997년 가장 많이 사용, 우리에게 중요한 버전
- HTTP/2.0 : 2015년 성능 개선
- HTTP/3.0 : TCP 대신에 UDP 사용, 성능 개선
  <br/>

- 참고로 1.1 에 대부분의 기능이 다 들어있고 이후 버전은 성능의 개선에 초점이 맞춰져 있다.
- 실제로 크롬 개발자도구에서 확인이 가능한데, 네크워크 창에서 프로토콜을 확인할 수 있다. h2 = http2, h3 = http3 이런식으로 확인이 가능하다.

> **HTTP 특징**

- 클라이언트 서버 구조
- 무상태 프로토콜, 비연결성
- HTTP 메세지
- 단순하고 확장이 가능하다

> **클라이언트 서버 구조**

- 클라이언트가 서버에 요청을 보내고, 서버가 응답을 보내면 그 응답 결과에 따라 클라이언트가 동작하게 된다.
- 당연한 이야기 같지만 사실 이렇게 클라이언트와 서버를 개념적으로 분리하고, 비즈니스로직 및 데이터로직을 서버에 집중시키고, 클라이언트는 사용성이나 UI에 집중을 한다.
- 이렇게 되면 좋은점이 각자 독립적으로 성능을 증가시킬 수 있다.

> **무상태 프로토콜(stateless)**

- 서버가 클라이언트의 상태를 보존하지 않는다는 의미다.
- 이 말은 이전 상태의 문맥을 보존하지 않는다는 것. 예시를 통해 한번 살펴보는게 좋다.
  <br />

- 예를 들어 애플 가게에서 맥북을 구매하는 상황을 살펴보자

  - 고객 : 노트북 구매할꼐요
  - 점원A : 노트북 한대는 200만원입니다.

  - 고객 : 2개 구매할꼐요
  - 점원B: ? 무엇을 2개 구매하나요

  - 고객 : 신용카드로 할께요
  - 점원C : ? 무엇을 몇개 신용카드로 구매하나요
    <br />

- 이처럼 만일 상태가 유지되는 상태라고 한다면 점원이 바뀌게 되면 그 상태유지가 이어지질 않아서 문제가 발생하게 된다.
- 이 점원을 서버로 치환하면, 만일 기존 서버가 문제가 발생하였다면 유지되고 있던 상태값이 전달이 되질 않아, 다른 서버에서 이를 해결하기가 어려워진다.
- 반면 무상태를 유지한다는 것은 매 연결마다 모든 정보를 다 담고 있다는 의미이다.
  <br />

- 같은 예시로 애플 가게에서 맥북을 구매하는 상황이다.

  - 고객: 노트북 구매할께요
  - 점원A: 한대당 200만원입니다.

  - 고객 : 노트북 2대 구매할께요
  - 점원B : 2대이니 400만원입니다.

  - 고객 : 노트북 2대 신용카드로 구매할께요
  - 점원C : 네 알겠습니다.
    <br />

- 이렇게 매 전달 때마다 완성된 정보를 전달하기에, 어떤 점원이 처리해도 다 응답이 가능해진다
- 즉, 어떤 서버가 처리한다고 해도 처리가 가능해지기 때문에, 서버를 무한정으로 확장시켜도 아무런 문제가 발생하지 않게 된다.
- 이렇기 때문에 무상태라는 것은 아주 중요한 패러다임이다.
- 다만, 로그인 같은 상태가 유지되어야 하는 상황이 있고, 이에 따라 쿠키세션으로 상태 유지하는 방법이 있다.
- 결론은 최대한 무상태를 유지하는것이 바람직하다는 것이다.

> **비연결성**

- HTTP 는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 1시간동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음. 왜냐면 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않기 때문
- 서버 자원을 매우 효율적으로 사용할 수 있음

> **비연결성의 단점**

- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간이 추가된다.
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함꼐 다운로드
- 이게 왜 문제냐면 만일 하나의 검색어를 검색했을 때, 서버에 요청하는 부분이 html 뿐이 아니라면 어떨까
- 연결을 유지하지 않기 때문에, html 요청, 자바스크립트 요청, css 요청, 이미지 요청 등등 모든 각각의 요청마다 연결을 다시 걸어야 하고 이건 3 way handshake 과정을 계속 거친다는 의미이다.
- 비효율적일 수밖에 없기 때문에 지금은 HTTP 에서 지속 연결(Persistent Connections)로 해결하고 있다.
- 지속 연결은 우선 연결을 처음 하고, 내부 매커니즘에 따라 몇 초간 연결을 유지한다는 식으로 지속적으로 연결을 해서 요청과 응답 세트를 계속해서 받는다. 그래서 위 문제를 해결했다
- HTTP/2, HTTP/3 에서는 더 성능이 확장되었다.

> **스테이스리스를 기억하자**

- 선착순 이벤트나 명절 KTX 예약 등은 비연결성의 장점이 모두 사라진다.
- 즉 한 순간에 엄청난 트래픽이 몰리기 때문이다.
- 방법이라면 어떻게든 스테이스리스를 유지하는 쪽으로 설계헤야 한다.

> **HTTP 메세지**

- HTTP 메세지의 구조는 아래와 같다.

```
star-line : 시작라인
header: 헤더
empty line: 공백 라인(CRLF)
message body
```

> **시작라인**

- 우선 요청 메시지
- 시작라인은 request-line / status-line 으로 구성이 된다.
- request-line 의 경우 method request-target HTTP-version
- 메서드는 종류로는 뭐 GET, POST, PUT, DELETE...
- 즉 서버가 수행해야 할 동작 지정
- 요청 메세지는 보통 절대 경로가 들어가고("/" 으로 시작하는)
  <br />

- 다음은 응답 메세지
- 시작 라인은 status-line 이며
- status-line 은 HTTP-version status-code reason-phrase 로 구성된다.

> **헤더**

- HTTP 전송에 필요한 모든 부가정보가 들어가있다.
- 예시로 메시지 바디의 내용, 메시지 바디 크기, 압축 됬는지, 인증정보, 요청 클라이언트 정보, 캐시 관리 정보 등등...
- 즉 필요한 메타 데이타가 다 들어가있다 생각하자

> **HTTP 메시지 바디**

- 실제 전송할 HTML, 이미지, 영상 등 데이터가 들어간다.

## 2023-1-22

### API URI

- 리소스의 의미는 예를 들어 회원을 등록하고 수정하는 API 를 설계한다고 하였을 때, 리소스는 바로 회원이다.
- 리소스를 식별한다는 것은 위 예시에서는 회원을 식별하면 되는 것이다.
- 다만 리소스만을 식별해서는 목적을 위한 URI 설계가 쉽지 않다.
- 그래서 리소스와 행위를 구별해야한다.
  - 리소스 : 회원
  - 행위 : 조회, 등록, 삭제, 변경
- 이러한 리소스를 설계한 예시를 보게 되면
  - 회원 목록 조회 : /members
  - 회원 조회 : /members/{id}
  - 회원 등록 : /members/{id}
  - 회원 수정 : /members/{id}
  - 회원 삭제 : /members/{id}
- 이렇게 되면 행위를 추가해주어야 하는데, 행위는 리소스에 넣지 않는것을 목표로 한다.
- 이 행위를 구별하는 것이 바로 HTTP 메서드이다.

### HTTP 메서드 : GET, POST

<p>가장 많이 사용되는 메서드인 GET, POST 기본으로 HTTP에는 크게 5가지 정도의 대표적인 메서드가 있다.</p>

- GET: 리소스 조회
- POST: 요청 데이터 처리, 주로 등록에 사용
- PUT: 리소스를 대체, 해당 리소스가 없으면 생성
- PATCH: 리소스 부분 변경
- DELETE: 리소스 삭제

<p>그 외의 메서드들은 다음과 같다.</p>

- HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS: 대상 리소스에 대한 통신 기능 옵션(메서드)을 설명(주로 CORS에서 사용)
- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

> **GET**

- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)을 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 권장하지 않는다. 보통은 쿼리 스트링으로 보내는 걸로 한다.

> **POST**

- 요청 데이터 처리
- 메시지 바디를 통해 서버로 요청 데이터를 전달
- 서버는 요청 데이터를 처리하는데, 바디로 들어온 모든 데이터를 다 처리한다. 주로 신규 데이터를 추가할때 사용한다.
- 근데 POST 는 다양한 의미를 지닌다.
- 예를 들어 POST 는 다음과 같은 기능에 사용된다.
  - HTML 양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공 (FORM 에서의 정보로 회원가입, 주문)
  - 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시
  - 서버가 아직 식별하지 않은 새 리소스 생성 (신규 주문 생성)
  - 기존 자원에 데이터 추가 (기존 자원 끝에 내용 추가)
- 정리를 해보겠다
- POST는 새 리소스를 생성(등록)한다.
  - 서버가 아직 식별하지 않은 새 리소스 생성
- POST는 요청 데이터를 처리해야 한다.
  - 예를 들어서 음식가게에서 어떤 배달에 대한 주문 결제가 완료었다고 할 때, 이제 사장님이 배달 시작이라는 요청을 시작할때 이때도 POST 로 보내야 한다.
  - 이처럼 변경하는것을 넘어 프로세스를 처리해야 하는 경우에도 POST 를 사용하게 된다.
  - 그렇기에 POST 를 통해 새로운 리소스가 생성되지 않을 수 있다. 로그인으로 보면 알 수 있을 것이다.
  - 이렇다보니 이전에 리소스에는 행위가 들어가면 안된다고 하였지만, POST 의 경우 안되는 경우가 있다. 그래서 동사를 리소스에 넣어주는 경우도 있고, 이러한 경우를 control-uri 라고 한다. (예 POST /orders/start-delivery)
- POST는 다른 메서드로 처리하기 애매한 경우 사용한다.
  - 예를 들어서 JSON 으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우 POST 를 사용한다.
  - 이렇게 애매하면 POST 를 사용한다.

> **PUT**

- PUT은 리소스를 대체하는 경우다. 어떠한 폴더에 기존 데이터를 넣으면 덮어써지게 되는 거처럼 PUT 도 이러한 경우다.
- 중요한것은 완전히 대체다. 리소스가 있다면 지금 우리가 보낸 데이터로 완전하게 대체해버린다.
- 기존데이터를 지워버리니 수정의 의미가 아니다.
- 중요한 점은 클라이언트가 리소스를 식별한다는 것에 있다.
- 주소를 예를 들면 /members/100 처럼 뒤에 특정 리소스 위치를 지정하게 된다.
- 이것은 /members 를 사용한 POST 와의 차이점이다.

> **PATCH**

- PUT 과 달리 부분 수정이 가능하다.
- 예를 들어 기존 데이터에 username, age 라는 데이터가 있었고
- 보내는 데이터는 age 만 있다면, PUT 은 age 만 남게 되지만, PATCH 는 age 만 수정되고 나머지 username 은 그대로 남아있는다.

> **DELETE**

- 말 그대로 리소스에 지정된 데이터를 제거한다.

### HTTP 메서드의 속성

> **안전**

- 호출해도 리소스를 변경하지 않는다.
- 안전의 경우 GET, HEAD 메서드
- 당연히 나머지는 데이터를 변경하니 안전하지 않다.
- 근데 계속 호출을 하면 서버에는 로그가 쌓이고 그래서 장애가 올 수 있지 않나? 라는 질문에 대한 대답은 '안전은 해당 리소스만 고려한다'

> **멱등(Idempotent)**

- 한번 호출하던 두번 호출하던 100번 호출하던 결과가 같아야 한다.
- GET : 한번 조회하든, 두번 조회하던 같은 결과가 조회된다.
- PUT : 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과가 같다. 생각을 해보자. 결과 응답은 같다. 내가 요청한 데이터가 나올테니말이다. 만약 데이터가 없다면 생성하여 그 데이터가 결과값이며, 이후 두번 보내게 되면 대체할테니 결과 데이터역시 동일하다.
- DELETE: 삭제 역시 동일하다. 만일 첫번째 호출에서 데이터를 삭제했다면 결과는 데이터가 삭제됨이다. 이후 2번 3번을 호춣해도 데이터는 삭제되어있다. 결과가 같다.
- POST: 멱등이 아니다. 두번 호출하면 같은 결제가 중복해서 발생할 수 있다.
- 만약 삭제요청을 했는데 응답 메시지가 없다면, 서버에서 알아서 삭제될때까지 요청을 하면 좋다. 왜냐하면 삭제는 멱등하기 때문이다. 결과값이 변하지 않는다.
- 이러한 자동 복귀 메커니즘에 활용이 가능하다.
  <br />

<p>근데 만약 외부에 의해 중간에 데이터가 변경이 되었다면, 멱등한 GET 을 사용한다 해도 멱등하다 할 수 있을까? 그에 대한 대답은 '멱등은 외부 요인에 의한 데이터 변경까지 고려하지 않는다'이다. 이런 부분은 서버에서 알아서 체크해야한다.</p>

> **캐시가능(Casheable)**

- 응답 결과 리소스를 캐시해서 사용해도 되는가?
- 보통 용량이 엄청 큰 이미지를 요청한다고 할 때, 이러한 데이터를 계속해서 요청해서 다운 받아오기에는 속도가 손해일테니, 데이터를 캐시화한다. 웹브라우저에서 한다
- GET, HEAD, POST, PATCH 는 가능하다.
- 다만 실제로는 GET, HEAD 를 사용한다. url 을 key 로 잡고 캐시화가 가능하기 떄문이다. body 까지 key 로 작업하기에는 어렵기 떄문.

## 2023-1-26

### HTTP 메서드 활용

> **클라이언트에서 서버로 데이터 전송**

- 쿼리 파라미터를 통해 데이터를 전송
  - GET
  - 주로 정렬 필터(검색어)
- 메시지 바디를 통한 데이터 전송
  - POST, PUT, PATCH
  - 회원 가입, 상품 주문, 리소스 등록, 리소스 변경

> **정적 데이터를 조회**

<p>정적 데이터를 조회하는 것은 쿼리파라미터가 필요없이 간단하게 리소스 만으로 조회가 가능하다</p>

- 이미지, 정적 텍스트 문서
- 조회는 GET 사용
- 정적 데이터는 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능

> **동적 데이터 조회**

<p>검색어나 페이지네이션 등 추가 데이터를 전달해야할 때 쿼리파라미터를 사용. 서버에서는 이 쿼리파라미터를 꺼낼 수 있다.</p>

- 주로 검색, 게시판 목록에서 정렬 필터(검색어)
- 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용
- 조회는 GET 사용
- GET 은 쿼리파라미터를 사용해서 데이터를 전달

> **HTML Form 데이터 전송**

<p>태그 중에 form 태그가 있는데, 이걸 활용해서 데이터를 전송할 수 있다.</p>

```js
<form action="/save" method="post">
  <input type='text' name='username'>
  <input type='text' name='age'>
  <button type="submit">전송<button>
</form>
```

- 이런 형식이 있다고 하면, 여기서 전송을 누를 시 HTTP 메시지가 생성이 된다.

```
POST /save HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded

username=kim&age=20
```

- 이런식으로 메시지가 전송이 된다. 만약 메서드가 GET 이라면

```
GET /save?username=kim&age=20 HTTP/1.1
Host: localhost:8080
```

- 이렇게 주소가 쿼리파라미터로 변경이 된다.
- 다만 주의할점은 Get 은 조회에만 사용해야한다. 데이터를 변경시키는 것을 하면 안된다.
- 위 예시는 save 니깐 사실 잘못된 예제

> **HTML Multi/Part Form-Data**

<p>이미지를 같이 전송할 때처럼, 여러 데이터 타입을 같이 보낼 수 있다.</p>

- 파일 업로드 같은 바이너리 데이터 전송시 사용
- 다른 종료의 여러 파일과 폼의 내용 함께 전송 가능(그래서 이름이 multipart)

### HTTP API 데이터 전송

```
POST /members HTTP/1.1
Content-Type: application/json

{
  usernama: kim
  age: 20
}

```

- 클라이언트 쪽의 라이브러리는 이를 자동적으로 잘 만들어준다.
- API 데이터 전송은 서버끼리의 통신에서 자주 사용되며, 웹 클라이언트의 경우도 자바스크립트의 AJAX 를 통해서 API 통신을 주로 한다.
- 기존에 활용했던 메서드를 그대로 활용할 수 있다. (POST, PATCH, PUT, GET)
- Content-Type: application/json 을 주로 사용(사실상 표준)
- 예전에는 XML 을 많이 사용했지만 최근에는 더 심플한 json 을 사용한다.

### HTTP API 설계 예시

<p>개략적으로 종류를 살펴보자</p>

- HTTP API - 컬렉션
  - POST 기반 등록
  - 예) 회원관리 API 제공
- HTTP API - 스토어
  - PUT 기반 등록
  - 예) 정적 컨텐츠 관리, 원격 파일 관리
- HTML FORM 사용
  - 웹 페이지 회원 관리
  - GET, POST 만 사용 가능

> **회원 관리 시스템을 설계한다 가정**

- 회원 목록 : GET /members
- 회원 등록 : POST /members
- 회원 조회 : GET /members/{id}
- 회원 수정 : PATCH,PUT,POST /members/{id}
- 회원 삭제 : DELETE /members/{id}

<p>여기서 post 를 통해 어떠한 회원을 등록시킨다고 가정해보자. post 로 회원을 등록시킬 때 클라이언트에서는 이 회원에 대한 등록될 리소스 URI 를 알 수 없다. API 를 통해 데이터를 전송시킬 뿐. 그렇다면 이 회원이 100번째 회원이라면, 그래서 클라이언트에서 이 회원을 조회하고 싶으면 이에 맞는 특정 URI 를 작성해야할텐데, 이러한 URI 는 서버에서 생성해준다. 이러한 특성을 컬렉션이라 한다.</p>

> **파일 관리 시스템 가정**

- 파일 목록 : GET /files
- 파일 조회 : GET /files/{filename}
- 파일 등록 : PUT /files/{filename}
- 파일 삭제 : DELETE /files/{filename}
- 파일 대량 등록 : POST /files

<p>특징이 있다. post 와 다르게 put 은 클라이언트가 리소스 URI 를 알고 있어야 한다. 즉, 클라이언트가 직접 URI 를 지정해야한다. 클라이언트가 직접 URI를 관리한다. 이러한 스타일의 관리를 스토어(Store) 라고 한다.</p><br />

<p>대부분은 post 를 사용한다는 점을 알고 있자. 즉 컬렉션 기반이다.</p>

> **HTML FORM 사용**

- HTML FORM 은 GET, POST 만 지원을 한다.
- AJAX 같은 기술을 사용해서 해결이 가능
- 하지만 일단은 HTML FORM 만 사용한다고 가정하자.
- GET, POST 만으로는 제약이 있어서 컨트롤 URI 를 사용해야한다.
- /new, /edit, /delete 가 컨트롤 URI (동사를 사용한다)
- HTTP 메서드로 해결하기 애매한 경우 사용하게 된다(HTTP API 포함)
- 단 최대한 기존 메서드를 활용해야 한다.
  <br />

- 회원 목록 : GET /members
- 회원 등록 폼 : GET /members/new
- 회원 등록 : POST /members/new
- 회원 조회 : GET /members/{id}
- 회원 수정 폼 : GET /members/{id}/edit
- 회원 수정 : POST /members/{id}/edit
- 회원 삭제 : POST /members/{id}/delete
