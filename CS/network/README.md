<h2 align="center"> Network </h1>
<h3 align="center"> 매일 공부한 부분을 간략하게 정리하자 </h3> 
<br />

<h2 id="프로젝트소개"> :book: 작성일 기록 </h2>

- [2023.1.17](#2023-1-17)
- [2023.1.18](#2023-1-18)
- [2023.1.21](#2023-1-21)

  <br />

![--------------------------------------------------------](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<h2 id="프로젝트소개"> :book: 간단한 요약 정리 </h2>

## 2023-1-17

### REST API 보안

<p>근래 대부분의 서비스는 API 를 기반으로 통신한다. 이에 따라 API 보안 역시 중요하다.</p>

### 인증(Authentication)

- 인증은 누가 서비스를 사용하는지 확인하는 절차
- 즉 아이디와 패스워드를 기입하여 사용자를 확인하게 된다.
- API 역시 마찬가지인데, API 를 호출하는 대상이 서버인지 사용자가 되었던지 결국 누구인지 확인하는 절차가 필요하다.

### 인가(Authorization)

- 인가는 해당 리소스에 대해 사용자가 그 리소스를 사용한 권리가 있는지 확인하는 체크 과정
- 로그인한 사람만(인증된 사람) 프로필 페이지를 사용할 수 있거나, 주문을 할 수 있는 등

### 네트워크 레벨 암호화

- 인증과 인가 과정이 끝나서 API 를 호출하게 되면, 네트워크를 통해서 데이터가 오가는데 이때 해커가 중간에서 이 통신을 감청할 수 없게 할 필요가 있다.
- 이에 네트워크 프로토콜단에서 암호화를 처리할 수 있는데, 이를 네트워크 암호화라고 한다. HTTP 기반에서의 네트워크 암호화는 일반적으로 HTTPS 기반의 프로토콜을 사용한다.

### 인증(Authentication) 방식의 종류

<p>API에 대한 인증 방식은 여러가지 방식이 있고, 보안수준과 구현수준이 다르기 때문에 구현하고자 하는 서비스의 특성을 살려서 적절한 API 인증 방식을 선택하여야 한다.</p>

> **API 키 방식**

- API key : 특정 사용자만 알수 있는 일종의 문자열.
- API를 호출하고자 할 때, 개발자는 API 제공사의 포탈 페이지에서 API 키를 발급 받고 API를 호출 할 때 API 키를 메세지 안에 넣는다. 서버는 메시지 안 API 키를 읽어서 누가 호출한 것인지 파악한다.
- 모든 클라이언트가 같은 key 를 공유하기에, 한번 key 가 노출되면 모든 API가 보안에서 취약해지기 때문에 높은 보안 인증이 필요할 때는 하지 않는다.

> **API 토큰**

- 사용자의 아이디와 비밀번호를 인증한 다음, 서버에서 일정 기간 유효한 토큰을 발급하는 방식이다.
- 매번 API 호출 시 아이디와 비밀번호를 보내지 않고 API 토큰을 사용하는 이유는 사용자와 비밀번호는 주기적으로 바뀔 수 있기 때문이고, 매번 네트워크를 통해서 사용자 ID와 비밀번호를 보내는 것은 보안상 계정 정보를 탈취당할 가능성이 크기 때문.

### Claim 기반은 JWT 방식

> **Claim 기반 토큰의 개념**

- 보통 token 의 경우 특별한 정보를 가지고 있지 않는다.
- 하지만 JWT는 Claim 기반이라는 방식을 사용하는데, Claim 은 사용자에 대한 프로퍼티나 속성을 말한다.

```js
{
  "id: "won",
  "role": "admin",
  "company": "pepsi",
}
```

- 이 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰 안에 다 들어가 있기 때문에, 다른 곳에서 가져올 필요가 없다는 장점이 있다.
- 결과적으로 토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없다. 서버 입장에서는 API 요청을 검증하기 위해 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다는 것.
- JWT 는 JSON Claim을 Base 64로 인코딩하여 HTTP 헤더에 쉽게 넣을 수 있다.

> **JWT 의 단점**

- Claim 에 넣는 데이터가 많아질수록 토큰 길이가 길어진다. 헤더에 붙여서 보내기 때문에 길이가 길어진다는 것은 네트워크 대역폭 낭비가 심하다는 의미.
- 한번 발급된 토큰은 수정하거나 폐기가 불가능하다. 그렇기 때문에 만료 시간을 꼭 명시하고 중간마다 토큰을 재 발행하여야 한다.
- 기본적으로 JWT 는 Claim 에 대한 정보를 암호화 하지는 않는다.

---

### 인터넷에서 통신을 하는 방법

> **IP**

- 우선 인터넷 프로토콜(IP) 에 대해서 알아야 한다.
- 인터넷 프로토콜의 역할은 지정된 IP 주소에 데이터를 전달하고, 패킷(Packet)이라는 통신 단위로 데이터를 전달
- IP 패킷에는 규칙이 있는데, 나의 IP(출발지), 목적지 IP, 전달 메세지 를 패킷에 넣고 전달한다.
- 목적지에서 패킷을 잘 받았다면, 반대로 목적지에서도 확인되었다는 패킷을 만들어서 클라이언트인 나에게 전달한다.
- 다만 한계가 있다. 패킷을 받을 대상이 없거나 서비스가 불능이라도 나는 패킷을 전송하게 된다. 응답이 없을 뿐. 즉, 받을 상태인지를 알 수가 없다.
- 인터넷망에서 전달한 패킷이 사라질수도 있고, 순서대로 도착하지 않을 수도 있다.
- 이런 문제들을 해결해주는 것이 TCP, UDP 이다.

> **TCP란**

- IP 프로토콜에서 발생하는 문제들을 해결해준다.
- 프로토콜에는 계층이 있다. 보통 OSI 7 Layer 를 들어봤을 것인데, 여기에 집중하지말고 우리가 파악하기 쉽게 해석하자면 크게 어플리케이션, OS, 네트워크 인터페이스로 구별된다 생각하자.
- 어플리케이션 : 우리가 사용하는 인터넷 등 프로그램과 SOCKET 라이브러리
- OS : TCD -> IP
- 네트워크 인터페이스 : LAN 드라이버, LAN 장비

<p>채팅 어플리케이션에서 hello 를 전달한다고 가정해보자</p>

- 어플리케이션에서 hello 메시지를 생성한다
- 이후 SOCKET 라이브러리를 통해 전달한다
- TCP 정보가 생성이되어 TCP 패킷을 통해 메시지를 감싼다
- 이후 IP 패킷이 생성되어 감싼다 (현재 TCP, IP 패킷 포함)
- LAN 카드에 의해 이더넷프레임을 씌어 전달한다.

<p>TCP에는 출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증정보... 등등 포함된다.이러한 TCP 의 특징은 다음과 같다.</p>

- 전송 제어 프로토콜(Transmission Control Protocol)
- 연결 지향: TCP 3 way handshake(가상 연결)
- 데이터 전달 보증
- 순서 보장

> **TCP 3 way handwhake**

- 우선 클라이언트에서 서버로 syn(싱크로나이즈) 라는 메시지를 보낸다.
- 서버에서는 syn 를 받고 확인한 다음 클라이언트에 ack 를 같이 클라이언트에 보낸다.
- 클라이언트는 ack 를 받고 확인한 뒤 ack 를 서버에 전달한다.
- 이렇게 3번 주고받으면서 클라이언트와 서버가 서로 신뢰할 수 있게 된다.
- 이제 연결이 된걸 확인했으니 그 다음에 데이터를 전송한다.
- 허나 주의할점이 있다. 클라이언트에서 서버까지 가는 과정에 수많은 서버들이 존재하는데, 이 모든 과정에 대한 연결 보장을 이야기하는것이 아니다. 그저 클라이언트와 서버간 연결이 되었구나 하고 생각하자. 즉 물리적 연결은 아니다.

> **데이터 전달 보증**

- 데이터를 전송했다면, 서버에서 데이터를 받았다는 확인 메세지를 전송한다.

> **순서 보장**

- 클라이언트에서 순서대로 패킷을 보내도, 서버에 패킷이 도착했을 때 순서가 잘못되어있다면 서버에서 다시 보내라고 신호를 보낸다.
- 이게 가능한 이유는 TCP 안에는 전송제어 정보, 순서 등등의 정보가 담겨져 있기 때문이다.

> **UDP**

- 사용자 데이터그램 프로토콜(User Datagram Protocol)
- UDP는 기능이 거의 없다. IP 와 비슷한데 추가된 부분은 PORT 부분이 있다.
- PORT 는 하나의 IP 를 사용하는 클라이언트가 여러가지 어플리케이션을 활용할 때, 각 어플리케이션 마다 서버에서 응답받는 패킷이 오게 될 것이고, 이를 구별하기 위해 사용하게 된다.
- 현재 인터넷 환경 자체는 TCP 가 다 먹고 있으며, 이제 건들수가 없다.
- 이 때 UDP 는 하얀 도화지로 비유가 되곤 하는데, 이 말은 이제 어떠한 새로운 기능이나 커스터마이징이 필요할 떄 UDP 를 사용할 수 있다는 것이고, 앞서서 설명한 TCP 의 3 way 방식등의 절차역시 없기에 속도 자체가 빠르다. 데이터 역시 적게 든다.
- 최근에는 hTTP3 에서 UDP 를 좀 더 활용해보고자 하고 있기에 주목받고 있다.

> **PORT**

- 우리가 게임도 하면서 화상통화도 하고 웹브라우저도 한다고 한다면, 하나의 클라이언트가 여러개의 서버와 연결을 해야한다.
- 패킷을 보낼때나 받을 때의 경우 이를 어떻게 구별할지에 대한 고민이 생겼다.
- TCP 패킷을 보게 되면 출발지 port 가 있고, 목적지 port 정보가 같이 들어간다.
- 이 port 를 통해서 패킷이 구별이 가능해진다.
- 비유를 하자면 Ip 가 아파트라면 port 는 동 호수라고 생각하자
- 기본적으로 0~65535 번까지 할당이 가능하지만, 0~1023 까지는 잘 알려진 포트라 사용하지 않는것이 좋다.

> **DNS**

- 우리가 IP 를 사용해서 통신을 할 때, IP를 매번 기억하는경우나, IP 가 중간에 변경되는 경우가 발생하면 문제가 된다.
- 이를 해결하기 위해 도메인(Domain Name System)을 사용할 수 있다.
- 우리가 구글에 접속하는 과정을 생각해보면 도메인이 어떻게 사용되는지 확인할 수 있다.
- www.google.com 을 입력하게 되면 DNS 서버에 전송이 되어 DNS 서버에서는 이 도메인에 맞는 IP 주소를 응답한다.
- IP 주소가 왔으니, 이제 이전 통신과정과 같다.

## 2023-1-18

### URI

> **URI**

- URI(Uniform Resource Identifier) 라는 리소스를 식별하는(주민번호로 사람을 식별 하는 것과같은) 가장 큰 개념이 있다.
- 이 URI 는 집합관계에서 URL 과 URN 을 감싸고 있다.
- URL(Resource Locator)(리소스의 위치를 지정) 과 URN(Resource Name)(리소스의 이름)
- 대부분 URL 만 쓴다. 그래서 그냥 URI 를 URL 로 파악하면 된다.
- 다시 넘어가 URI 를 살펴보면
- Uniform : 리소스 식별하는 통일된 방식
- Resource : 자원, URI로 식별할 수 있는 모든 것(제한없음)
- Identifier : 다른 항목과 구분하는데 필요한 정보

```
http://www.google.com/search?q=hello&hl=ko
```

- 위 URL 형태를 보게 되면 아래와 같이 구성됨을 알 수 있다.
- scheme://[userinfo@]host[:port]/[/path][?query][#fragment]

> **scheme**

- scheme 에는 주로 프로토콜을 사용한다. 프로토콜이란 어떤 방식으로 자원에 접근할 것인가에 대한 약속이자 규칙이다.
- http는 80 포트, https 는 443 포트를 사용하며, 이렇기에 생략이 가능하다.

> **userinfo**

- 거의 사용하지는 않음.

> **host**

- 호스트명
- 도메인명 또는 IP 주소를 직접 사용 가능하다.

> **host**

- 접속 포트이며 일반적으로 생략이 가능하다. 생략시 http는 80. https 는 443 이다.

> **path**

- 리소스의 경로이며 계층적인 구조가 많다
- /home/members/100 (100번에 있는 회원의 정보) -> 이런식으로 계층적으로 설계되는 경우가 많다.

> **query**

- key=value 형태이며 ?로 시작한다. &으로 추가가 가능하다. ?keyA=valueA&keyB=valueB

> **fragment**

- html 내부 북마크 등에서 사용하며 서버에 전송하는 정보는 아니다.

### 웹 브라우저 요청 흐름

- 앞서 다뤘던 구글 검색 URL 을 다시 참고해보자

```
https://www.google.com/search?q=hello&hl=ko
```

- 웹 브라우저는 구글이라는 도메인 네임을 DNS 서버에서 조회를 해서 서버 IP 를 가져온다. 또한 https 를 통해 생략된 포트 443 역시 가져온다
- 이 다음 http 요청 메세지를 생성한다. 이 메세지를 간략히 적으면 아래와 같다.

```
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
```

- SOCKET 라이브러리를 통해 생성한 메세지를 os 의 TCP/IP와 연결한다.
- 처음 과정은 앞에서 배웠듯이 syn,ack 과정인 3 way handshake 과정을 통해 통신하려는 서버와 연결할 수 있는지 확인을 한다.
- 이후 확인이 됬으면 TCP/IP 에서 패킷을 생성하여 메세지에 첨부한다. (이때 메세지에 아까 브라우저에서 만든 요청 메세지)
- 서버가 이 요청 패킷을 받게 되면, 메세지를 해석하게 되며 그에대한 응답 메세지를 만들게 된다.
- 이후 똑같이 패킷에 씌어서 이 응답메세지를 브라우저에 보내주게 된다.
- 컨텐츠에 따라 다르겠지만, 보통은 html 문서가 오기 때문에, 브라우저는 이 html 을 렌더링 하게 된다.

## 2023-1-21

### 모든것이 HTTP

> **HTTP**
> <br />

- HTTP 는 HyperText Transfer Protocol 의 약자
- 현재는 거의 모든 형태의 데이터를 다 전송할 수 있다.
- 서버간에 데이터를 주고 받을때도 거진 HTTP 를 활용해서 전송한다.

> **HTTP의 역사**
> <br />

- HTTP/0.9 : 1991년 GET 메서드만 지원, HTTP 헤더없음
- HTTP/1.0 : 1996년 메서드와 헤더가 추가됨
- HTTP/1.1 : 1997년 가장 많이 사용, 우리에게 중요한 버전
- HTTP/2.0 : 2015년 성능 개선
- HTTP/3.0 : TCP 대신에 UDP 사용, 성능 개선
  <br/>

- 참고로 1.1 에 대부분의 기능이 다 들어있고 이후 버전은 성능의 개선에 초점이 맞춰져 있다.
- 실제로 크롬 개발자도구에서 확인이 가능한데, 네크워크 창에서 프로토콜을 확인할 수 있다. h2 = http2, h3 = http3 이런식으로 확인이 가능하다.

> **HTTP 특징** > <br />

- 클라이언트 서버 구조
- 무상태 프로토콜, 비연결성
- HTTP 메세지
- 단순하고 확장이 가능하다

> **클라이언트 서버 구조** > <br />

- 클라이언트가 서버에 요청을 보내고, 서버가 응답을 보내면 그 응답 결과에 따라 클라이언트가 동작하게 된다.
- 당연한 이야기 같지만 사실 이렇게 클라이언트와 서버를 개념적으로 분리하고, 비즈니스로직 및 데이터로직을 서버에 집중시키고, 클라이언트는 사용성이나 UI에 집중을 한다.
- 이렇게 되면 좋은점이 각자 독립적으로 성능을 증가시킬 수 있다.

> **무상태 프로토콜(stateless)** > <br />

- 서버가 클라이언트의 상태를 보존하지 않는다는 의미다.
- 이 말은 이전 상태의 문맥을 보존하지 않는다는 것. 예시를 통해 한번 살펴보는게 좋다.
  <br />

- 예를 들어 애플 가게에서 맥북을 구매하는 상황을 살펴보자

  - 고객 : 노트북 구매할꼐요
  - 점원A : 노트북 한대는 200만원입니다.

  - 고객 : 2개 구매할꼐요
  - 점원B: ? 무엇을 2개 구매하나요

  - 고객 : 신용카드로 할께요
  - 점원C : ? 무엇을 몇개 신용카드로 구매하나요
    <br />

- 이처럼 만일 상태가 유지되는 상태라고 한다면 점원이 바뀌게 되면 그 상태유지가 이어지질 않아서 문제가 발생하게 된다.
- 이 점원을 서버로 치환하면, 만일 기존 서버가 문제가 발생하였다면 유지되고 있던 상태값이 전달이 되질 않아, 다른 서버에서 이를 해결하기가 어려워진다.
- 반면 무상태를 유지한다는 것은 매 연결마다 모든 정보를 다 담고 있다는 의미이다.
  <br />

- 같은 예시로 애플 가게에서 맥북을 구매하는 상황이다.

  - 고객: 노트북 구매할께요
  - 점원A: 한대당 200만원입니다.

  - 고객 : 노트북 2대 구매할께요
  - 점원B : 2대이니 400만원입니다.

  - 고객 : 노트북 2대 신용카드로 구매할께요
  - 점원C : 네 알겠습니다.
    <br />

- 이렇게 매 전달 때마다 완성된 정보를 전달하기에, 어떤 점원이 처리해도 다 응답이 가능해진다
- 즉, 어떤 서버가 처리한다고 해도 처리가 가능해지기 때문에, 서버를 무한정으로 확장시켜도 아무런 문제가 발생하지 않게 된다.
- 이렇기 때문에 무상태라는 것은 아주 중요한 패러다임이다.
- 다만, 로그인 같은 상태가 유지되어야 하는 상황이 있고, 이에 따라 쿠키세션으로 상태 유지하는 방법이 있다.
- 결론은 최대한 무상태를 유지하는것이 바람직하다는 것이다.

> **비연결성**
> <br />

- HTTP 는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 1시간동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음. 왜냐면 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않기 때문
- 서버 자원을 매우 효율적으로 사용할 수 있음

> **비연결성의 단점**
> <br />

- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간이 추가된다.
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함꼐 다운로드
- 이게 왜 문제냐면 만일 하나의 검색어를 검색했을 때, 서버에 요청하는 부분이 html 뿐이 아니라면 어떨까
- 연결을 유지하지 않기 때문에, html 요청, 자바스크립트 요청, css 요청, 이미지 요청 등등 모든 각각의 요청마다 연결을 다시 걸어야 하고 이건 3 way handshake 과정을 계속 거친다는 의미이다.
- 비효율적일 수밖에 없기 때문에 지금은 HTTP 에서 지속 연결(Persistent Connections)로 해결하고 있다.
- 지속 연결은 우선 연결을 처음 하고, 내부 매커니즘에 따라 몇 초간 연결을 유지한다는 식으로 지속적으로 연결을 해서 요청과 응답 세트를 계속해서 받는다. 그래서 위 문제를 해결했다
- HTTP/2, HTTP/3 에서는 더 성능이 확장되었다.

> **스테이스리스를 기억하자**
> <br />

- 선착순 이벤트나 명절 KTX 예약 등은 비연결성의 장점이 모두 사라진다.
- 즉 한 순간에 엄청난 트래픽이 몰리기 때문이다.
- 방법이라면 어떻게든 스테이스리스를 유지하는 쪽으로 설계헤야 한다.

> **HTTP 메세지**
> <br />

- HTTP 메세지의 구조는 아래와 같다.

```
star-line : 시작라인
header: 헤더
empty line: 공백 라인(CRLF)
message body
```

> **시작라인**
> <br />

- 우선 요청 메시지
- 시작라인은 request-line / status-line 으로 구성이 된다.
- request-line 의 경우 method request-target HTTP-version
- 메서드는 종류로는 뭐 GET, POST, PUT, DELETE...
- 즉 서버가 수행해야 할 동작 지정
- 요청 메세지는 보통 절대 경로가 들어가고("/" 으로 시작하는)
  <br />

- 다음은 응답 메세지
- 시작 라인은 status-line 이며
- status-line 은 HTTP-version status-code reason-phrase 로 구성된다.

> **헤더**
> <br />

- HTTP 전송에 필요한 모든 부가정보가 들어가있다.
- 예시로 메시지 바디의 내용, 메시지 바디 크기, 압축 됬는지, 인증정보, 요청 클라이언트 정보, 캐시 관리 정보 등등...
- 즉 필요한 메타 데이타가 다 들어가있다 생각하자

> **HTTP 메시지 바디**
> <br />

- 실제 전송할 HTML, 이미지, 영상 등 데이터가 들어간다.
