<h2 align="center"> Network </h1>
<h3 align="center"> 매일 공부한 부분을 간략하게 정리하자 </h3> 
<br />

<h2 id="프로젝트소개"> :book: 작성일 기록 </h2>

- [2023.1.17](#2023-1-17)

  <br />

![--------------------------------------------------------](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<h2 id="프로젝트소개"> :book: 간단한 요약 정리 </h2>

## 2023-1-17

### REST API 보안

<p>근래 대부분의 서비스는 API 를 기반으로 통신한다. 이에 따라 API 보안 역시 중요하다.</p>

### 인증(Authentication)

- 인증은 누가 서비스를 사용하는지 확인하는 절차
- 즉 아이디와 패스워드를 기입하여 사용자를 확인하게 된다.
- API 역시 마찬가지인데, API 를 호출하는 대상이 서버인지 사용자가 되었던지 결국 누구인지 확인하는 절차가 필요하다.

### 인가(Authorization)

- 인가는 해당 리소스에 대해 사용자가 그 리소스를 사용한 권리가 있는지 확인하는 체크 과정
- 로그인한 사람만(인증된 사람) 프로필 페이지를 사용할 수 있거나, 주문을 할 수 있는 등

### 네트워크 레벨 암호화

- 인증과 인가 과정이 끝나서 API 를 호출하게 되면, 네트워크를 통해서 데이터가 오가는데 이때 해커가 중간에서 이 통신을 감청할 수 없게 할 필요가 있다.
- 이에 네트워크 프로토콜단에서 암호화를 처리할 수 있는데, 이를 네트워크 암호화라고 한다. HTTP 기반에서의 네트워크 암호화는 일반적으로 HTTPS 기반의 프로토콜을 사용한다.

### 인증(Authentication) 방식의 종류

<p>API에 대한 인증 방식은 여러가지 방식이 있고, 보안수준과 구현수준이 다르기 때문에 구현하고자 하는 서비스의 특성을 살려서 적절한 API 인증 방식을 선택하여야 한다.</p>

> **API 키 방식**

- API key : 특정 사용자만 알수 있는 일종의 문자열.
- API를 호출하고자 할 때, 개발자는 API 제공사의 포탈 페이지에서 API 키를 발급 받고 API를 호출 할 때 API 키를 메세지 안에 넣는다. 서버는 메시지 안 API 키를 읽어서 누가 호출한 것인지 파악한다.
- 모든 클라이언트가 같은 key 를 공유하기에, 한번 key 가 노출되면 모든 API가 보안에서 취약해지기 때문에 높은 보안 인증이 필요할 때는 하지 않는다.

> **API 토큰**

- 사용자의 아이디와 비밀번호를 인증한 다음, 서버에서 일정 기간 유효한 토큰을 발급하는 방식이다.
- 매번 API 호출 시 아이디와 비밀번호를 보내지 않고 API 토큰을 사용하는 이유는 사용자와 비밀번호는 주기적으로 바뀔 수 있기 때문이고, 매번 네트워크를 통해서 사용자 ID와 비밀번호를 보내는 것은 보안상 계정 정보를 탈취당할 가능성이 크기 때문.

### Claim 기반은 JWT 방식

> **Claim 기반 토큰의 개념**

- 보통 token 의 경우 특별한 정보를 가지고 있지 않는다.
- 하지만 JWT는 Claim 기반이라는 방식을 사용하는데, Claim 은 사용자에 대한 프로퍼티나 속성을 말한다.

```js
{
  "id: "won",
  "role": "admin",
  "company": "pepsi",
}
```

- 이 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰 안에 다 들어가 있기 때문에, 다른 곳에서 가져올 필요가 없다는 장점이 있다.
- 결과적으로 토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없다. 서버 입장에서는 API 요청을 검증하기 위해 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다는 것.
- JWT 는 JSON Claim을 Base 64로 인코딩하여 HTTP 헤더에 쉽게 넣을 수 있다.

> **JWT 의 단점**

- Claim 에 넣는 데이터가 많아질수록 토큰 길이가 길어진다. 헤더에 붙여서 보내기 때문에 길이가 길어진다는 것은 네트워크 대역폭 낭비가 심하다는 의미.
- 한번 발급된 토큰은 수정하거나 폐기가 불가능하다. 그렇기 때문에 만료 시간을 꼭 명시하고 중간마다 토큰을 재 발행하여야 한다.
- 기본적으로 JWT 는 Claim 에 대한 정보를 암호화 하지는 않는다.

---

### 인터넷에서 통신을 하는 방법

> **IP**

- 우선 인터넷 프로토콜(IP) 에 대해서 알아야 한다.
- 인터넷 프로토콜의 역할은 지정된 IP 주소에 데이터를 전달하고, 패킷(Packet)이라는 통신 단위로 데이터를 전달
- IP 패킷에는 규칙이 있는데, 나의 IP(출발지), 목적지 IP, 전달 메세지 를 패킷에 넣고 전달한다.
- 목적지에서 패킷을 잘 받았다면, 반대로 목적지에서도 확인되었다는 패킷을 만들어서 클라이언트인 나에게 전달한다.
- 다만 한계가 있다. 패킷을 받을 대상이 없거나 서비스가 불능이라도 나는 패킷을 전송하게 된다. 응답이 없을 뿐. 즉, 받을 상태인지를 알 수가 없다.
- 인터넷망에서 전달한 패킷이 사라질수도 있고, 순서대로 도착하지 않을 수도 있다.
- 이런 문제들을 해결해주는 것이 TCP, UDP 이다.

> **TCP란**

- IP 프로토콜에서 발생하는 문제들을 해결해준다.
- 프로토콜에는 계층이 있다. 보통 OSI 7 Layer 를 들어봤을 것인데, 여기에 집중하지말고 우리가 파악하기 쉽게 해석하자면 크게 어플리케이션, OS, 네트워크 인터페이스로 구별된다 생각하자.
- 어플리케이션 : 우리가 사용하는 인터넷 등 프로그램과 SOCKET 라이브러리
- OS : TCD -> IP
- 네트워크 인터페이스 : LAN 드라이버, LAN 장비

<p>채팅 어플리케이션에서 hello 를 전달한다고 가정해보자</p>

- 어플리케이션에서 hello 메시지를 생성한다
- 이후 SOCKET 라이브러리를 통해 전달한다
- TCP 정보가 생성이되어 TCP 패킷을 통해 메시지를 감싼다
- 이후 IP 패킷이 생성되어 감싼다 (현재 TCP, IP 패킷 포함)
- LAN 카드에 의해 이더넷프레임을 씌어 전달한다.

<p>TCP에는 출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증정보... 등등 포함된다.이러한 TCP 의 특징은 다음과 같다.</p>

- 전송 제어 프로토콜(Transmission Control Protocol)
- 연결 지향: TCP 3 way handshake(가상 연결)
- 데이터 전달 보증
- 순서 보장

> **TCP 3 way handwhake**

- 우선 클라이언트에서 서버로 syn(싱크로나이즈) 라는 메시지를 보낸다.
- 서버에서는 syn 를 받고 확인한 다음 클라이언트에 ack 를 같이 클라이언트에 보낸다.
- 클라이언트는 ack 를 받고 확인한 뒤 ack 를 서버에 전달한다.
- 이렇게 3번 주고받으면서 클라이언트와 서버가 서로 신뢰할 수 있게 된다.
- 이제 연결이 된걸 확인했으니 그 다음에 데이터를 전송한다.
- 허나 주의할점이 있다. 클라이언트에서 서버까지 가는 과정에 수많은 서버들이 존재하는데, 이 모든 과정에 대한 연결 보장을 이야기하는것이 아니다. 그저 클라이언트와 서버간 연결이 되었구나 하고 생각하자. 즉 물리적 연결은 아니다.

> **데이터 전달 보증**

- 데이터를 전송했다면, 서버에서 데이터를 받았다는 확인 메세지를 전송한다.

> **순서 보장**

- 클라이언트에서 순서대로 패킷을 보내도, 서버에 패킷이 도착했을 때 순서가 잘못되어있다면 서버에서 다시 보내라고 신호를 보낸다.
- 이게 가능한 이유는 TCP 안에는 전송제어 정보, 순서 등등의 정보가 담겨져 있기 때문이다.

> **UDP**

- 사용자 데이터그램 프로토콜(User Datagram Protocol)
- UDP는 기능이 거의 없다. IP 와 비슷한데 추가된 부분은 PORT 부분이 있다.
- PORT 는 하나의 IP 를 사용하는 클라이언트가 여러가지 어플리케이션을 활용할 때, 각 어플리케이션 마다 서버에서 응답받는 패킷이 오게 될 것이고, 이를 구별하기 위해 사용하게 된다.
- 현재 인터넷 환경 자체는 TCP 가 다 먹고 있으며, 이제 건들수가 없다.
- 이 때 UDP 는 하얀 도화지로 비유가 되곤 하는데, 이 말은 이제 어떠한 새로운 기능이나 커스터마이징이 필요할 떄 UDP 를 사용할 수 있다는 것이고, 앞서서 설명한 TCP 의 3 way 방식등의 절차역시 없기에 속도 자체가 빠르다. 데이터 역시 적게 든다.
- 최근에는 hTTP3 에서 UDP 를 좀 더 활용해보고자 하고 있기에 주목받고 있다.

> **PORT**

- 우리가 게임도 하면서 화상통화도 하고 웹브라우저도 한다고 한다면, 하나의 클라이언트가 여러개의 서버와 연결을 해야한다.
- 패킷을 보낼때나 받을 때의 경우 이를 어떻게 구별할지에 대한 고민이 생겼다.
- TCP 패킷을 보게 되면 출발지 port 가 있고, 목적지 port 정보가 같이 들어간다.
- 이 port 를 통해서 패킷이 구별이 가능해진다.
- 비유를 하자면 Ip 가 아파트라면 port 는 동 호수라고 생각하자
- 기본적으로 0~65535 번까지 할당이 가능하지만, 0~1023 까지는 잘 알려진 포트라 사용하지 않는것이 좋다.

> **DNS**

- 우리가 IP 를 사용해서 통신을 할 때, IP를 매번 기억하는경우나, IP 가 중간에 변경되는 경우가 발생하면 문제가 된다.
- 이를 해결하기 위해 도메인(Domain Name System)을 사용할 수 있다.
- 우리가 구글에 접속하는 과정을 생각해보면 도메인이 어떻게 사용되는지 확인할 수 있다.
- www.google.com 을 입력하게 되면 DNS 서버에 전송이 되어 DNS 서버에서는 이 도메인에 맞는 IP 주소를 응답한다.
- IP 주소가 왔으니, 이제 이전 통신과정과 같다.
