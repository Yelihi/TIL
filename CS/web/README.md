<h2 align="center"> Network </h1>
<h3 align="center"> 매일 공부한 부분을 간략하게 정리하자 </h3> 
<br />

<h2 id="프로젝트소개"> :book: 작성일 기록 </h2>

- [2023.1.20](#2023-1-20)
- [2023.2.2](#2023-2-2)

  <br />

![--------------------------------------------------------](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<h2 id="프로젝트소개"> :book: 간단한 요약 정리 </h2>

## 2023-1-20

### Cookie

- Cookie 는 한마디로 트럭처럼 어떠한 전달 매체라고 생각하는것이 좋다.
- 사용자가 웹 페이지를 접근하게 되면, 브라우저에서 서버로 요청을 보내게 된다. 이후 서버에서는 응답으로 쿠키를 같이 보내게 된다.
- 쿠키에는 여러 정보가 담길 수 있다. 이러한 쿠키는 브라우저에 저장이 되어있고, 이후 웹 페이지에 접근할 때마다 자동적으로 헤더에 쿠키를 넣어서 전송하게 된다.
- 물론 쿠키는 특정 웹사이트에 한해 독립적으로 전달이 된다. 유튜브라면 유튜브에 해당하는 쿠키가 전달이 된다는 의미.
- 쿠키에는 정보가 담길 수 있고, 이를 이용해서 인증 인가를 처리할 수 있다. 하지만 쿠키만을 사용해 인증과 인가를 하는것은 매우 위험하다.

### Session

- 웹 프로토콜(HTTP)는 stateless 를 유지한다. 즉 한번 요청과 이후 응답을 받았다면 이후 연결과정은 끊키게 된다. 한번의 요청과 한번의 응답!
- 예를 들어 로그인이라는 요청을 보냈고 서버에서 확인을 해보니 사용자가 적합하여 OK 사인을 보내 로그인이 되었다고 하자.
- 이때 요청은 로그인이며 응답은 확인이다. 즉 로그인이 필요한 다른 페이지에 접근할 때는 stateless 이기 때문에 서버는 이 유저가 로그인된 사람인지 알 수 없다.
- 방법은 매 페이지마다 로그인 요청을 보내는 것이다. 그리고 그에 대한 응답을 받는다. 하지만 이러한 방식은 너무나도 비효율적이다.
- 이를 위해 Session 이 필요하게 되었다. 그리고 브라우저에서 매 요청마다 헤더에 자동적으로 담기는 쿠키를 활용하는 것이다.
- 서버는 Session ID(외 다른것들도..)를 저장할 수 있는 DB 를 생성한다.
- 즉 브라우저에서 사용자가 로그인 요청을 하였고, 서버측에서 확인이 된다면, 응답과정에서 쿠키안에 세션 ID 를 넣어서 전송한다. 즉 쿠키에는 세션 ID 가 저장이 되어있다.
- 이후 인가가 필요한 페이지에 접근할 때마다 브라우저는 쿠키를 서버에 전송하고, 서버에서는 쿠키안에 담긴 세션 ID(로그인되면 DB 에 저장되어있음)를 확인한 뒤, 로그인된 유저라면 서버는 우리를 로그인된 유저라고 인식할 수 있게 된다. 이후 인가를 해줄 것이다.
- 세션의 장점중 하나라면 쿠키내부에 직접 아이디나 패스워드등 유저의 인증 정보를 담지 않는다는 점에 있다. 즉 세션 ID 가 해킹당해도 유저 정보가 해킹당하진 않는다.
- 또한 세션은 DB 에 로그인된 유저를 저장하기 때문에, 이 유저들에 대한 후속조치를 취할 수 있다.
- 하지만 분명 DB 가 필요하고, 유저가 많아지면 많아질수록 DB 역시 증대되어야 하기에 비용적인 부분에서 손해가 발생할 수 있다.

### JWT

- 웹 브라우저는 쿠키를 가지고 있고, 이를 요청 헤더에 자동으로 추가시킨다. 하지만 안드로이드나 IOS 는 웹이 아니기 때문에 쿠키가 없다.
- 이때 대신 사용하는것이 토큰이다. 토큰은 일련의 랜덤하기도 한 문자열이다. 데이터에 제한이 있는 쿠키와 달리 토큰은 제한이 없는걸로 알고 있다.
- 다만, 이 토큰에는 정보가 담겨져있는 것은 아니다. 마치 쿠키에 세션 ID 가 없는것처럼 말이다.
- 이에 이 토큰에 유저의 정보를 담은 것을 JWT 방식이라고 한다. (Claim 방식)
- JWT 의 경우 토큰 자체에 유저의 정보가 담겨있고 (마치 쿠키에 모든 유저의 정보가 담겨있다고 생각해도 된다) 이를 통해 서버에 요청 시 서버는 토큰을 해석하여 유저정보를 확인하고 인가를 해주게 된다.
- 얼핏 세션과 비슷하다고 생각할 수 있으나, 중요한 차이점은 JWT 는 따로 DB 가 필요가 없다는 점에 있다. 즉 토큰을 서버에 보내기만 하면 인증과 인가 과정을 해결할 수 있는 것이다.
- 사용자가 광범위하게 많아질 수록 JWT 는 세션보다 더 유리할 수 있다. (예를 들어 코로나 QR 인증과 같은)
  - 클라이언트 사용자가 아이디, 패스워드를 통해 웹 서비스 인증
  - 서버에서 서명된(Signed) JWT 를 생성하여 클라이언트에 응답으로 돌려주기
  - 클라이언트가 서버에 데이터를 추가적으로 요구할 때 JWT 를 HTTP Header 에 첨부
  - 서버에서 클라이언트로 온 JWT 를 검증
- JWT는 json 데이터를 base64 를 통해 인코딩하여 직렬화 한것이며, 내부에 위변조를 방지하기위해 개인키를 통한 전자서명이 있다.
- JWT 는 Header, Payload, Signnature 로 구성이 된다. 그리고 이 3가지는 . 으로 연결이 된다.
- Header 에는 JWT에서 사용할 타입과 알고리즘이 담겨있다.
- Payload 는 실제 유저의 정보나 권한이 담겨있다.
- Signature 에는 Header 에 명시된 해시함수를 적용하고 개인키로 서명한 전자서명이 담겨있다.
- 즉 Signature 에는 base64 로 인코딩된 header와 payload가 있고, 개인서명(JWT secret 혹은 salt) 이 3가지를 header에서 명시한 암호 알고리즘으로 해시하여 사용자에게 전달된다.
- 당연히 서버에서는 복호화를 할 수 있고, 특히 개인서명은 서버가 임의적으로 생성한 것이기에, 해커가 만일 payload 를 변경하여 서버에 요청하려 하더라도 사인이 맞지 않게 되기 때문에 요청을 거부하게 된다.
- 이러한 원리를 이용하는 대표적인 라이브러리로는 bcrypt 가 있다. (알고리즘과 salt 가 주어지고 마지막엔 이를 활용해서 해쉬한 패스워드가 붙는다)
- 마지막으로 장단점을 알아보고 마치겠다

  - 기존 쿠키와 달리 어플리케이션에서 인증 절차로 토큰이 활용중이고, JWT 역시 토큰이기에 범용성이 좋다
  - 단, payload 가 많아지면 토큰이 커져서 서버의 부담이 갈 수 있다.
  - 토큰이 재발급 되기 전까지 사용자 정보가 갱신되더라도 적용되지 않는 문제가 있다.
  - Restful 한 무상태(Stateless) 환경에서의 통신이 용이하고 사용하기 쉽다.
  - 데이터를 자체적으로 가지고 있어서 데이터를 얻기 위한 타 서비스에 다시 요청하는 횟수가 줄어 서버의 부담이 줄어들게 된다.
  - 토큰의 만료시간이 있는 경우 만료시간까지는 강제적으로 만료시킬 수 없으므로 노출이 되어서는 안되며 중요정보를 넣는 일은 없어야 한다.

  ## 2023-2-2

  ### cookie의 구성과 자바스크립트로 조작하기

<p>브라우저 내 application > cookie 를 자바스크립트로 직접 조작하는것은 사실 좋은것은 아니다. 자바스크립트를 통해 조작이 가능하다면, 해커가 이를 접근해서 악용할 수 있기 때문이다. 처음 서버에서 쿠키를 전송할 때 만료일자를 설정할 수 있고, 이 만료일자를 통해서 쿠키를 자연스럽게 삭제하는 방향을 주로 사용하곤 한다.</p><br />

<p>그럼에도 상황에 따라 쿠키를 제어할 수 있어야 하고, 아직까지 쿠키를 다루는 데 있어서 모르는 부분이 많다보니, 우선 자바스크립트내에서 쿠키를 다루는 방법을 한번 학습해보자</p>

> **Cookie 구성**

<p>위에서 쿠키의 역할에 대해서 간략하게 설명하였었으니, 자바스크립트내에서 쿠키를 생성하는 방향과 각각의 속성들에 대해서 살펴보자</p>

```js
Document.cookie = "Name=value; Expire=날짜; Domain=도메인; Path=경로; max-age=초; secure";
```

- Name
  - Name은 데이터 쿠키의 이름이며 반드시 지정을 해주어야 한다.(생성할때는)
- Expire
  - 쿠키의 파기 날짜를 지정하는 속성이다. 이 속성에는 GMT나 UTC 형식으로 날짜를 입력해야 한다.
  - 이 날짜를 입력하지 않으면 브라우저가 종료될 때 쿠키가 삭제된다.
  - 반대로 날짜를 설정해놓으면 브라우저을 껏다가 다시 켜도 쿠키가 유지된다.
- max-age
  - expire의 보완버전이자 만료되기까지의 시간을 정할 수 있다.
  - 초 단위로 예를 들어 10을 작성하면, 쿠키가 10초 되 파기된다는 의미이다.
  - 만약 0이나 음수를 입력하면 그 즉시 쿠키가 파기된다.
- Secure
  - 이 속성을 지정하면 쿠키는 SSL을 사용해서만 요청할 수 있다.(즉, https 를 써야만)
- Domain
  - 기본값으로는 현재 도메인의 경로로 자동 입력된다
  - 페이지 요청과 비교하여 도메인의 경로와 Domain 의 속성이 일치하지않으면, 쿠키에 접근하는 것을 막으므로 Domain 속성은 건드리지 않는다.
- Path 속성
  - 이 속성을 입력하지않으면 현제 도메인 경로로 자동 입력된다
  - 이 속성은 /폴더/ 로 설정되는데, 이렇게 설정하면 이 폴더부터 하위까지 접근이 가능하다.
  - path 속성을 / 으로 하면 도메인 내 모든 곳에서 접근할 수 있다.
  - 예를 들어 /admin 을 설정해놓으면 이 path 와 그 하위는 쿠키에 접근할 수 있지만, /home 과 같이 다른 path 에서는 접근할 수 없다.
  - 그래서 그냥 / 을 하는게 편하다

<p>즉, 어떠한 이벤트에 의해 쿠키를 삭제하고 싶다면 아래와 같이 작성하면 된다.</p>

```js
document.cookie = "name=; max-age=-1; path=/";
```

- 여기서 path 는 사용자에 따라 다르게 지정하면 된다.

<p>참고로 쿠키를 생성할때는 형식의 유효성을 일관성있게 유지하기 위해 내장함수를 사용하자</p>

```js
let name = "my name";
let value = "wonik";

document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);
```

<p>이 외에도 특정 속성들이 있는데, 주로 보안과 관련된 속성들이다</p>

> **samesite**

<p>예를 들어서 은행 사이트 bank.com 에 로그인한 상태라고 생각해보자. 은행 서비스를 이용하다가 새로운 창을 여러서 다른 웹서핑을 하던 도중 evil.com 에 접속했다고 가정하자. 이 악의에 찬 사이트는 자동적으로 해커에서 송금을 요구하는 form 이 있고, 자동으로 제출되도록 설정되어있다. 이 form 은 action으로 bank.com/pay 로 되어있어 evil.com -> bank.com 으로 바로 전송이 되게 된다. 이때 bank.com 에 접근할 때 브라우저에 있는 쿠키도 같이 전송되게 된다. 왜냐하면 로그인이 되어있었으니깐. 은행은 이를 모르고 실제 해커에게 돈을 송금하게 됩니다.</p>

<p>이러한 공격을 크로스 사이트 요청 위조(XSRF)라고 한다. 보통 bank에는 이에 대한 대비책으로 XSRF 보호 토큰을 가지고 있다. 이 토큰은 악의적인 페이지에서 만들 수 없고 훔칠수도 없게 설계되어있어서 이 토큰이 없다면 요청이 의미없어지게되니 이러한 공격을 막을 수 있다. 다만 구현에도 시간이 걸리고 모든 요청에 대해서 검수를 해야하니, 우선적으로 브라우저에서 차단하는 방법이 있다. 그것이 samesite 속성이다.</p>

- samesite=strict 옵션을 이용하면, 사용자가 외부에서 요청을 보낼 때, 이 옵션이 있는 쿠키는 절대로 전송되지 않는다.
- 즉 제 3의 도메인에서 요청이 이뤄질 땐 쿠키가 전송되지 않는다.
- 쿠키가 전송이 안되니 당연히 송금 요청도 이뤄지지 않게 된다.
- 다만 예를 들어 어떠한 메모장에 링크를 옮겨놓고, 추후에 그 링크를 통해 bank.com 을 접속할 때, samesite 설정에 의해 쿠키가 전송되지 않게될 수 있다.
- 방법이라면 일반 인증용 쿠키를 설정하고, 데이터 교환시 사용하는 쿠키를 따로 두는 방식이 있다.

<p>이러한 samesite 의 문제점은 오래된 브라우저(2017년 이전버전)에서는 지원하지 않는다는 점이다. 그래서 이것만 믿고 보안 처리를 하면 문제가 발생할 수 있다.</p>

> **httpOnly**

<p>이번에 쿠키를 설정하면서 false 로 설정해두었던 속성이다. 이 속성이 true 이면(디폴트값) 자바스크립트에서 쿠키에 접근할 수 없다. 즉, 위에서 설정하는 document.cookie 를 통해서 접근이 불가능하다는 의미. 이를 통해 해커가 자바스크립트로 쿠키에 접근하는것을 사전에 막을 수 있다. 반대로 말하자면 왠만하면 이 속성은 true 로 해두는것이 좋다는 의미.</p>
